"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTaskBuildContext = createTaskBuildContext;
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const atomic_1 = require("../storage/atomic");
const paths_1 = require("../storage/paths");
const DEFAULT_TEXT_ENCODING = "utf8";
const DEFAULT_JSON_EXTENSION = ".json";
const MAX_BLOB_BASENAME_LENGTH = 128;
const HASH_SUFFIX_LENGTH = 10;
function createTaskBuildContext(options) {
    const runId = mustBeNonEmpty(options.runId, "runId");
    const runDir = path_1.default.resolve(mustBeNonEmpty(options.runDir, "runDir"));
    const effectId = mustBeNonEmpty(options.effectId, "effectId");
    const invocationKey = mustBeNonEmpty(options.invocationKey, "invocationKey");
    const taskId = mustBeNonEmpty(options.taskId, "taskId");
    const tasksRoot = (0, paths_1.getTasksDir)(runDir);
    const taskDir = path_1.default.join(tasksRoot, effectId);
    const normalizedLabel = normalizeLabel(options.label);
    const labels = normalizedLabel ? [normalizedLabel] : [];
    const ctx = {
        effectId,
        invocationKey,
        taskId,
        runId,
        runDir,
        taskDir,
        tasksDir: tasksRoot,
        label: normalizedLabel,
        labels,
        async createBlobRef(name, value, blobOptions) {
            const prepared = prepareBlobContents(value, blobOptions);
            const blobName = buildBlobFileName(name, prepared.defaultExtension, prepared.contents);
            const blobDir = path_1.default.join(taskDir, "blobs");
            await fs_1.promises.mkdir(blobDir, { recursive: true });
            const blobPath = path_1.default.join(blobDir, blobName);
            await (0, atomic_1.writeFileAtomic)(blobPath, prepared.contents);
            return toRunRelative(runDir, blobPath);
        },
        toTaskRelativePath(relativePath) {
            const normalized = normalizeTaskRelativePath(relativePath);
            const absolute = path_1.default.join(taskDir, normalized);
            return toRunRelative(runDir, absolute);
        },
    };
    return Object.freeze(ctx);
}
function mustBeNonEmpty(value, field) {
    if (typeof value !== "string" || !value.trim()) {
        throw new Error(`TaskBuildContext requires a non-empty ${field}`);
    }
    return value.trim();
}
function normalizeLabel(label) {
    if (!label)
        return undefined;
    const trimmed = label.trim();
    return trimmed.length ? trimmed : undefined;
}
function buildBlobFileName(rawName, defaultExtension, contents) {
    const safeName = sanitizeBlobName(rawName, defaultExtension);
    const digest = hashBuffer(contents);
    return appendDigestSuffix(safeName, digest);
}
function sanitizeBlobName(rawName, defaultExtension) {
    if (typeof rawName !== "string") {
        throw new Error("Blob name must be a non-empty string");
    }
    const trimmed = rawName.trim();
    if (!trimmed.length) {
        throw new Error("Blob name must be a non-empty string");
    }
    const normalized = trimmed.replace(/[\\/]+/g, "/");
    const segments = normalized.split("/").filter(Boolean);
    let safe = segments.join("-").replace(/[^a-zA-Z0-9._-]/g, "-");
    safe = safe.replace(/-+/g, "-");
    safe = safe.replace(/^[-.]+/, "").replace(/[-.]+$/, "");
    if (!safe.length) {
        throw new Error("Blob name must include alphanumeric characters");
    }
    if (defaultExtension && !safe.includes(".")) {
        const ext = defaultExtension.startsWith(".") ? defaultExtension : `.${defaultExtension}`;
        safe = `${safe}${ext}`;
    }
    return clampBlobName(safe);
}
function clampBlobName(name) {
    if (name.length <= MAX_BLOB_BASENAME_LENGTH) {
        return name;
    }
    const ext = path_1.default.posix.extname(name);
    const base = ext ? name.slice(0, -ext.length) : name;
    const available = Math.max(8, MAX_BLOB_BASENAME_LENGTH - ext.length - HASH_SUFFIX_LENGTH - 1);
    const truncated = base.slice(0, available);
    const suffix = hashString(name);
    return ext ? `${truncated}-${suffix}${ext}` : `${truncated}-${suffix}`;
}
function appendDigestSuffix(name, digest) {
    if (!digest)
        return name;
    const ext = path_1.default.posix.extname(name);
    if (!ext) {
        return `${name}-${digest}`;
    }
    return `${name.slice(0, -ext.length)}-${digest}${ext}`;
}
function normalizeTaskRelativePath(value) {
    if (typeof value !== "string") {
        throw new Error("Relative path must be a string");
    }
    const trimmed = value.trim();
    if (!trimmed.length) {
        throw new Error("Relative path must be non-empty");
    }
    if (path_1.default.isAbsolute(trimmed)) {
        throw new Error("Task-relative paths must not be absolute");
    }
    const replaced = trimmed.replace(/\\/g, "/");
    const segments = replaced.split("/").filter(Boolean);
    if (!segments.length) {
        throw new Error("Relative path must include a filename");
    }
    const normalized = [];
    for (const segment of segments) {
        if (segment === ".")
            continue;
        if (segment === "..") {
            throw new Error("Task-relative paths cannot traverse above the task directory");
        }
        normalized.push(segment);
    }
    if (!normalized.length) {
        throw new Error("Relative path must include a filename");
    }
    return normalized.join("/");
}
function toRunRelative(runDir, absolutePath) {
    const relative = path_1.default.relative(runDir, absolutePath);
    if (!relative || relative.startsWith("..") || path_1.default.isAbsolute(relative)) {
        throw new Error(`Path ${absolutePath} is not inside run directory ${runDir}`);
    }
    return relative.split(path_1.default.sep).join("/");
}
function hashString(value) {
    return crypto_1.default.createHash("sha1").update(value).digest("hex").slice(0, HASH_SUFFIX_LENGTH);
}
function hashBuffer(contents) {
    return crypto_1.default.createHash("sha256").update(contents).digest("hex");
}
function prepareBlobContents(value, options) {
    const treatAsJson = shouldSerializeAsJson(value, options);
    if (typeof value === "string" && !treatAsJson) {
        const encoding = options?.encoding ?? DEFAULT_TEXT_ENCODING;
        return {
            contents: Buffer.from(value, encoding),
        };
    }
    if (Buffer.isBuffer(value) && !treatAsJson) {
        return {
            contents: value,
        };
    }
    const normalizedValue = value === undefined ? null : value;
    const serialized = JSON.stringify(normalizedValue, null, 2) ?? "null";
    const withNewline = serialized.endsWith("\n") ? serialized : `${serialized}\n`;
    return {
        contents: Buffer.from(withNewline, DEFAULT_TEXT_ENCODING),
        defaultExtension: DEFAULT_JSON_EXTENSION,
    };
}
function shouldSerializeAsJson(value, options) {
    if (options?.asJson !== undefined) {
        return options.asJson;
    }
    return !(typeof value === "string" || Buffer.isBuffer(value));
}
