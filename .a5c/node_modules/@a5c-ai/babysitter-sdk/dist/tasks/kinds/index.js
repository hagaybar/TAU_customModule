"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeTask = nodeTask;
exports.breakpointTask = breakpointTask;
exports.orchestratorTask = orchestratorTask;
exports.sleepTask = sleepTask;
const defineTask_1 = require("../defineTask");
const DEFAULT_NODE_TIMEOUT_MS = 15 * 60 * 1000;
const DEFAULT_BREAKPOINT_LABEL = "breakpoint";
const DEFAULT_ORCHESTRATOR_LABEL = "orchestrator-task";
const DEFAULT_SLEEP_TASK_ID = "__sdk.sleep";
const REDACTION_KEYWORDS = ["SECRET", "TOKEN", "PASSWORD", "KEY"];
function nodeTask(id, options) {
    if (!options || !options.entry) {
        throw new Error("nodeTask requires an entry option");
    }
    return (0, defineTask_1.defineTask)(id, async (args, ctx) => {
        const [entry, title, description, helperLabels, helperMetadata, ioOverrides, nodeArgs, envInput, cwd, timeoutOverride,] = await Promise.all([
            resolveRequiredValue(options.entry, args, ctx, "entry"),
            resolveOptionalValue(options.title, args, ctx),
            resolveOptionalValue(options.description, args, ctx),
            resolveLabelList(options.labels, args, ctx),
            resolveMetadata(options.metadata, args, ctx),
            resolveIoHints(options.io, args, ctx),
            resolveStringArray(options.args, args, ctx),
            resolveEnv(options.env, args, ctx),
            resolveOptionalValue(options.cwd, args, ctx),
            resolveNumber(options.timeoutMs, args, ctx),
        ]);
        const io = applyIoOverrides(buildDefaultNodeIo(ctx), ioOverrides);
        const { env, redacted } = sanitizeEnv(envInput);
        const metadata = appendRedactedEnvKeys(helperMetadata, redacted);
        const labels = mergeLabels(ctx, helperLabels);
        const nodeOptions = buildNodeOptions(entry, nodeArgs, env, cwd, timeoutOverride);
        return {
            kind: "node",
            title,
            description,
            labels,
            io,
            metadata,
            node: nodeOptions,
        };
    }, { kind: "node" });
}
function breakpointTask(id, options = {}) {
    return (0, defineTask_1.defineTask)(id, async (args, ctx) => {
        const [title, description, helperLabels, metadata, payload, confirmationRequired] = await Promise.all([
            resolveOptionalValue(options.title, args, ctx),
            resolveOptionalValue(options.description, args, ctx),
            resolveLabelList(options.labels, args, ctx),
            resolveMetadata(options.metadata, args, ctx),
            resolveOptionalValue(options.payload, args, ctx),
            resolveBoolean(options.confirmationRequired, args, ctx),
        ]);
        const labels = mergeLabels(ctx, helperLabels, DEFAULT_BREAKPOINT_LABEL);
        const breakpoint = buildBreakpointOptions(payload ?? args, confirmationRequired);
        const resolvedTitle = title ?? ctx.label ?? labels?.[0] ?? DEFAULT_BREAKPOINT_LABEL;
        return {
            kind: "breakpoint",
            title: resolvedTitle,
            description,
            labels,
            metadata,
            breakpoint,
        };
    }, { kind: "breakpoint" });
}
function orchestratorTask(id, options = {}) {
    return (0, defineTask_1.defineTask)(id, async (args, ctx) => {
        const [title, description, helperLabels, metadata, payload, resumeCommand] = await Promise.all([
            resolveOptionalValue(options.title, args, ctx),
            resolveOptionalValue(options.description, args, ctx),
            resolveLabelList(options.labels, args, ctx),
            resolveMetadata(options.metadata, args, ctx),
            resolvePayload(options.payload, args, ctx),
            resolveOptionalValue(options.resumeCommand, args, ctx),
        ]);
        const labels = mergeLabels(ctx, helperLabels, DEFAULT_ORCHESTRATOR_LABEL);
        const orchestrator = buildOrchestratorOptions(payload ?? pickJsonRecord(args), resumeCommand);
        const mergedMetadata = ensureMetadata(metadata);
        mergedMetadata.orchestratorTask = true;
        const resolvedTitle = title ?? ctx.label ?? labels?.[0] ?? DEFAULT_ORCHESTRATOR_LABEL;
        return {
            kind: "orchestrator_task",
            title: resolvedTitle,
            description,
            labels,
            metadata: mergedMetadata,
            orchestratorTask: orchestrator,
        };
    }, { kind: "orchestrator_task" });
}
function sleepTask(id = DEFAULT_SLEEP_TASK_ID, options = {}) {
    return (0, defineTask_1.defineTask)(id, async (args, ctx) => {
        const [title, description, helperLabels, metadata] = await Promise.all([
            resolveOptionalValue(options.title, args, ctx),
            resolveOptionalValue(options.description, args, ctx),
            resolveLabelList(options.labels, args, ctx),
            resolveMetadata(options.metadata, args, ctx),
        ]);
        const iso = args.iso;
        const targetEpochMs = args.targetEpochMs;
        if (typeof iso !== "string" || !iso.length) {
            throw new Error("sleepTask requires args.iso to be a non-empty ISO string");
        }
        if (typeof targetEpochMs !== "number" || !Number.isFinite(targetEpochMs)) {
            throw new Error("sleepTask requires args.targetEpochMs to be a finite number");
        }
        const labels = mergeLabels(ctx, helperLabels, `sleep:${iso}`);
        const mergedMetadata = ensureMetadata(metadata);
        mergedMetadata.iso = iso;
        mergedMetadata.targetEpochMs = targetEpochMs;
        const resolvedTitle = title ?? `sleep:${iso}`;
        return {
            kind: "sleep",
            title: resolvedTitle,
            description,
            labels,
            metadata: mergedMetadata,
            sleep: { iso, targetEpochMs },
        };
    }, { kind: "sleep" });
}
async function resolveOptionalValue(source, args, ctx) {
    if (source === undefined || source === null)
        return undefined;
    const value = isFactory(source) ? await source(args, ctx) : source;
    return value === null ? undefined : value;
}
async function resolveRequiredValue(source, args, ctx, field) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (typeof value !== "string" || !value.trim()) {
        throw new Error(`nodeTask requires a non-empty ${field}`);
    }
    return value;
}
async function resolveLabelList(source, args, ctx) {
    const values = await resolveOptionalValue(source, args, ctx);
    if (!Array.isArray(values)) {
        return undefined;
    }
    return normalizeLabels(values);
}
async function resolveMetadata(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (!isJsonRecord(value)) {
        return undefined;
    }
    return { ...value };
}
async function resolveIoHints(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (!value)
        return undefined;
    return { ...value };
}
async function resolveStringArray(source, args, ctx) {
    const values = await resolveOptionalValue(source, args, ctx);
    if (!Array.isArray(values)) {
        return undefined;
    }
    return values.slice();
}
async function resolveEnv(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (!value || typeof value !== "object") {
        return undefined;
    }
    return { ...value };
}
async function resolveNumber(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (typeof value !== "number" || !Number.isFinite(value)) {
        return undefined;
    }
    return value;
}
async function resolveBoolean(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (typeof value !== "boolean") {
        return undefined;
    }
    return value;
}
async function resolvePayload(source, args, ctx) {
    const value = await resolveOptionalValue(source, args, ctx);
    if (!isJsonRecord(value)) {
        return undefined;
    }
    return { ...value };
}
function isFactory(value) {
    return typeof value === "function";
}
function normalizeLabels(values) {
    if (!Array.isArray(values)) {
        return undefined;
    }
    const seen = new Set();
    const normalized = [];
    for (const label of values) {
        if (typeof label !== "string")
            continue;
        const trimmed = label.trim();
        if (!trimmed || seen.has(trimmed))
            continue;
        seen.add(trimmed);
        normalized.push(trimmed);
    }
    return normalized.length ? normalized : undefined;
}
function mergeLabels(ctx, helperLabels, fallback) {
    const combined = [];
    combined.push(...(normalizeLabels(ctx.labels) ?? []));
    combined.push(...(helperLabels ?? []));
    const normalized = normalizeLabels(combined);
    const fallbackLabel = typeof fallback === "string" ? fallback.trim() : undefined;
    if ((!ctx.label || !ctx.label.trim()) && (!normalized || normalized.length === 0) && fallbackLabel) {
        return [fallbackLabel];
    }
    return normalized;
}
function buildDefaultNodeIo(ctx) {
    return {
        inputJsonPath: ctx.toTaskRelativePath("inputs.json"),
        outputJsonPath: ctx.toTaskRelativePath("result.json"),
        stdoutPath: ctx.toTaskRelativePath("stdout.log"),
        stderrPath: ctx.toTaskRelativePath("stderr.log"),
    };
}
function applyIoOverrides(base, override) {
    if (!override) {
        return base;
    }
    return {
        ...base,
        ...override,
    };
}
function sanitizeEnv(input) {
    if (!input) {
        return { redacted: [] };
    }
    const env = {};
    const redacted = [];
    for (const [rawKey, rawValue] of Object.entries(input)) {
        const key = typeof rawKey === "string" ? rawKey.trim() : "";
        if (!key)
            continue;
        if (rawValue === undefined || rawValue === null) {
            continue;
        }
        const value = typeof rawValue === "string" ? rawValue : String(rawValue);
        if (shouldRedactEnvKey(key)) {
            redacted.push(key);
            continue;
        }
        env[key] = value;
    }
    redacted.sort((a, b) => a.localeCompare(b));
    return {
        env: Object.keys(env).length ? env : undefined,
        redacted,
    };
}
function shouldRedactEnvKey(key) {
    const upper = key.toUpperCase();
    if (upper === "NODE_AUTH_TOKEN") {
        return true;
    }
    return REDACTION_KEYWORDS.some((keyword) => upper.includes(keyword));
}
function appendRedactedEnvKeys(metadata, keys) {
    if (!keys.length) {
        return metadata;
    }
    const result = ensureMetadata(metadata);
    const existingValue = result.redactedEnvKeys;
    const existing = Array.isArray(existingValue)
        ? existingValue.filter((v) => typeof v === "string")
        : [];
    const merged = Array.from(new Set([...existing, ...keys]));
    merged.sort((a, b) => a.localeCompare(b));
    result.redactedEnvKeys = merged;
    return result;
}
function ensureMetadata(metadata) {
    if (metadata && typeof metadata === "object" && !Array.isArray(metadata)) {
        return { ...metadata };
    }
    return {};
}
function buildNodeOptions(entry, args, env, cwd, timeoutOverride) {
    const nodeOptions = { entry };
    if (args !== undefined) {
        nodeOptions.args = args;
    }
    if (env) {
        nodeOptions.env = env;
    }
    if (typeof cwd === "string" && cwd.length) {
        nodeOptions.cwd = cwd;
    }
    nodeOptions.timeoutMs = typeof timeoutOverride === "number" ? timeoutOverride : DEFAULT_NODE_TIMEOUT_MS;
    return nodeOptions;
}
function buildBreakpointOptions(payload, confirmationRequired) {
    const breakpoint = {};
    if (payload !== undefined) {
        breakpoint.payload = payload;
    }
    if (confirmationRequired !== undefined) {
        breakpoint.confirmationRequired = confirmationRequired;
    }
    return breakpoint;
}
function buildOrchestratorOptions(payload, resumeCommand) {
    const orchestrator = {};
    if (payload) {
        orchestrator.payload = payload;
    }
    if (resumeCommand) {
        orchestrator.resumeCommand = resumeCommand;
    }
    return orchestrator;
}
function pickJsonRecord(value) {
    if (!isJsonRecord(value)) {
        return undefined;
    }
    return { ...value };
}
function isJsonRecord(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
