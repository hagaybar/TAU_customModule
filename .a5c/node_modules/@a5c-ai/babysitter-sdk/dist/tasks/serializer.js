"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESULT_SCHEMA_VERSION = exports.TASK_SCHEMA_VERSION = void 0;
exports.serializeAndWriteTaskDefinition = serializeAndWriteTaskDefinition;
exports.serializeTaskDefinition = serializeTaskDefinition;
exports.serializeAndWriteTaskResult = serializeAndWriteTaskResult;
exports.serializeTaskResult = serializeTaskResult;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const tasks_1 = require("../storage/tasks");
const paths_1 = require("../storage/paths");
const atomic_1 = require("../storage/atomic");
exports.TASK_SCHEMA_VERSION = "2026.01.tasks-v1";
exports.RESULT_SCHEMA_VERSION = "2026.01.results-v1";
const BLOB_THRESHOLD_BYTES = 1024 * 1024; // 1 MiB
async function serializeAndWriteTaskDefinition(options) {
    const serialized = await serializeTaskDefinition(options);
    const taskRef = await (0, tasks_1.writeTaskDefinition)(options.runDir, options.effectId, serialized);
    return {
        taskRef,
        inputsRef: serialized.inputsRef,
        serialized,
    };
}
async function serializeTaskDefinition(options) {
    const normalized = normalizeTaskDef(options.task);
    const serialized = {
        schemaVersion: exports.TASK_SCHEMA_VERSION,
        effectId: options.effectId,
        taskId: options.taskId,
        invocationKey: options.invocationKey,
        stepId: options.stepId,
        kind: normalized.kind,
        title: normalized.title,
        description: normalized.description,
        labels: normalized.labels,
        io: normalized.io,
        node: normalized.node,
        breakpoint: normalized.breakpoint,
        orchestratorTask: normalized.orchestratorTask,
        sleep: normalized.sleep,
        metadata: normalized.metadata,
    };
    if (options.inputs !== undefined) {
        const spill = await maybeSpillLargeValue({
            runDir: options.runDir,
            effectId: options.effectId,
            name: "inputs",
            value: options.inputs,
        });
        serialized.inputs = spill.value;
        serialized.inputsRef = spill.ref;
    }
    return serialized;
}
async function serializeAndWriteTaskResult(options) {
    const serialized = await serializeTaskResult(options);
    const { resultRef, stdoutRef, stderrRef } = await (0, tasks_1.writeTaskResult)({
        runDir: options.runDir,
        effectId: options.effectId,
        result: serialized,
        stdout: options.payload.stdout,
        stderr: options.payload.stderr,
    });
    return {
        resultRef,
        stdoutRef,
        stderrRef,
        serialized,
    };
}
async function serializeTaskResult(options) {
    const serialized = {
        schemaVersion: exports.RESULT_SCHEMA_VERSION,
        effectId: options.effectId,
        taskId: options.taskId,
        invocationKey: options.invocationKey,
        status: options.payload.status,
        result: undefined,
        resultRef: undefined,
        error: normalizeError(options.payload.error),
        stdoutRef: options.payload.stdoutRef,
        stderrRef: options.payload.stderrRef,
        startedAt: options.payload.startedAt,
        finishedAt: options.payload.finishedAt,
        metadata: options.payload.metadata ? stableClone(options.payload.metadata) : undefined,
    };
    if (options.payload.status === "ok") {
        const spill = await maybeSpillLargeValue({
            runDir: options.runDir,
            effectId: options.effectId,
            name: "result",
            value: options.payload.result,
        });
        serialized.result = spill.value;
        serialized.value = spill.value;
        serialized.resultRef = spill.ref;
    }
    else {
        serialized.error = normalizeError(options.payload.error);
    }
    return serialized;
}
function normalizeTaskDef(task) {
    if (!task || typeof task !== "object") {
        throw new Error("Task serializer requires a TaskDef object");
    }
    if (!task.kind || typeof task.kind !== "string") {
        throw new Error("TaskDef.kind must be a non-empty string");
    }
    return {
        kind: task.kind,
        title: typeof task.title === "string" ? task.title : undefined,
        description: typeof task.description === "string" ? task.description : undefined,
        labels: normalizeLabels(task.labels),
        io: normalizeJson(task.io),
        node: normalizeJson(task.node),
        breakpoint: normalizeJson(task.breakpoint),
        orchestratorTask: normalizeJson(task.orchestratorTask),
        sleep: normalizeJson(task.sleep),
        metadata: normalizeJson(task.metadata),
    };
}
function normalizeLabels(labels) {
    if (!Array.isArray(labels) || labels.length === 0)
        return undefined;
    const trimmed = labels
        .filter((value) => typeof value === "string")
        .map((label) => label.trim())
        .filter(Boolean);
    if (!trimmed.length)
        return undefined;
    const unique = Array.from(new Set(trimmed));
    unique.sort((a, b) => a.localeCompare(b));
    return unique;
}
function normalizeJson(value) {
    if (!value || typeof value !== "object") {
        return undefined;
    }
    if (Array.isArray(value)) {
        return undefined;
    }
    return stableClone(value);
}
async function maybeSpillLargeValue(options) {
    if (options.value === undefined) {
        return {};
    }
    const clone = stableClone(options.value);
    const json = JSON.stringify(clone, null, 2) + "\n";
    if (Buffer.byteLength(json, "utf8") <= BLOB_THRESHOLD_BYTES) {
        return { value: clone };
    }
    const blobDir = path_1.default.join((0, paths_1.getTasksDir)(options.runDir), options.effectId, "blobs");
    await fs_1.promises.mkdir(blobDir, { recursive: true });
    const hash = crypto_1.default.createHash("sha256").update(json).digest("hex");
    const blobPath = path_1.default.join(blobDir, `${options.name}-${hash}.json`);
    await fs_1.promises.mkdir(path_1.default.dirname(blobPath), { recursive: true });
    await (0, atomic_1.writeFileAtomic)(blobPath, json);
    return {
        ref: toRunRelative(options.runDir, blobPath),
    };
}
function toRunRelative(runDir, absolutePath) {
    const relative = path_1.default.relative(runDir, absolutePath);
    return relative.split(path_1.default.sep).join("/");
}
function stableClone(value) {
    if (Array.isArray(value)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return value.map((entry) => stableClone(entry));
    }
    if (value && typeof value === "object") {
        const entries = Object.keys(value).sort((a, b) => a.localeCompare(b));
        const clone = {};
        for (const key of entries) {
            const child = value[key];
            clone[key] = stableClone(child);
        }
        return clone;
    }
    return value;
}
function normalizeError(error) {
    if (!error || typeof error !== "object") {
        return undefined;
    }
    return stableClone(error);
}
