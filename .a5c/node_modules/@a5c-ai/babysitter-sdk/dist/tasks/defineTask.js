"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineTask = defineTask;
const registry_1 = require("./registry");
function defineTask(id, impl, options = {}) {
    const taskId = normalizeTaskId(id);
    registerTaskId(taskId, options);
    const defined = {
        id: taskId,
        async build(args, ctx) {
            const taskDef = await Promise.resolve(impl(args, ctx));
            const normalized = normalizeTaskDef(taskDef);
            const mergedLabels = [...(options.labels ?? []), ...(normalized.labels ?? [])];
            registry_1.globalTaskRegistry.recordDefinitionMetadata(taskId, {
                kind: normalized.kind,
                description: normalized.description ?? options.description,
                labels: mergedLabels,
            });
            return normalized;
        },
    };
    return Object.freeze(defined);
}
function registerTaskId(taskId, options) {
    try {
        registry_1.globalTaskRegistry.registerDefinition({
            id: taskId,
            kind: options.kind,
            description: options.description,
            labels: options.labels ?? [],
            source: options.source,
        });
    }
    catch (error) {
        if (error instanceof registry_1.DuplicateTaskIdError) {
            throw error;
        }
        throw new registry_1.DuplicateTaskIdError(taskId);
    }
}
function normalizeTaskId(id) {
    if (typeof id !== "string" || !id.trim()) {
        throw new Error("defineTask requires a non-empty string id");
    }
    return id.trim();
}
function normalizeTaskDef(taskDef) {
    if (!taskDef || typeof taskDef !== "object") {
        throw new Error("Task implementations must return a TaskDef object");
    }
    const labels = Array.isArray(taskDef.labels)
        ? taskDef.labels.filter((label) => typeof label === "string" && Boolean(label.trim()))
        : undefined;
    if (labels) {
        taskDef.labels = Array.from(new Set(labels.map((label) => label.trim())));
    }
    return taskDef;
}
