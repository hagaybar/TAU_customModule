"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalTaskRegistry = exports.TaskRegistry = exports.DuplicateTaskIdError = void 0;
exports.resetGlobalTaskRegistry = resetGlobalTaskRegistry;
class DuplicateTaskIdError extends Error {
    constructor(taskId) {
        super(`Task id "${taskId}" is already registered`);
        this.name = "DuplicateTaskIdError";
    }
}
exports.DuplicateTaskIdError = DuplicateTaskIdError;
class TaskRegistry {
    definitions = new Map();
    effects = new Map();
    registerDefinition(record) {
        if (this.definitions.has(record.id)) {
            throw new DuplicateTaskIdError(record.id);
        }
        const normalized = {
            id: record.id,
            kind: record.kind,
            labels: normalizeLabels(record.labels),
            description: record.description,
            source: record.source,
        };
        this.definitions.set(record.id, normalized);
        return normalized;
    }
    recordDefinitionMetadata(taskId, metadata) {
        const current = this.definitions.get(taskId);
        if (!current) {
            this.definitions.set(taskId, {
                id: taskId,
                labels: normalizeLabels(metadata.labels ?? []),
                kind: metadata.kind,
                description: metadata.description,
                source: metadata.source,
            });
            return;
        }
        this.definitions.set(taskId, {
            ...current,
            ...metadata,
            labels: normalizeLabels(metadata.labels ?? current.labels),
        });
    }
    recordEffect(record) {
        const normalizedLabels = normalizeLabels(record.labels ?? []);
        const normalized = {
            ...record,
            label: normalizeLabelValue(record.label),
            labels: normalizedLabels.length ? normalizedLabels : undefined,
            kind: record.kind,
            status: record.status,
            inputsRef: record.inputsRef,
        };
        this.effects.set(record.effectId, normalized);
        return normalized;
    }
    resolveEffect(effectId, update) {
        const current = this.effects.get(effectId);
        if (!current)
            return undefined;
        const next = {
            ...current,
            ...update,
        };
        if (update.status) {
            next.status = update.status;
        }
        this.effects.set(effectId, next);
        return next;
    }
    get(effectId) {
        return this.effects.get(effectId);
    }
    listPending(filter) {
        const pending = Array.from(this.effects.values()).filter((record) => record.status === "pending");
        return pending
            .filter((record) => this.matchesKind(record, filter?.kind) && this.matchesLabel(record, filter?.labels))
            .sort((a, b) => a.effectId.localeCompare(b.effectId));
    }
    listDefinitions() {
        return Array.from(this.definitions.values()).sort((a, b) => a.id.localeCompare(b.id));
    }
    hasTask(taskId) {
        return this.definitions.has(taskId);
    }
    clear() {
        this.definitions.clear();
        this.effects.clear();
    }
    matchesKind(record, kinds) {
        if (!kinds)
            return true;
        const asArray = Array.isArray(kinds) ? kinds : [kinds];
        if (!asArray.length)
            return true;
        return asArray.some((kind) => kind === record.kind);
    }
    matchesLabel(record, labels) {
        if (!labels)
            return true;
        const values = Array.isArray(labels) ? labels : [labels];
        if (!values.length)
            return true;
        const metadataLabels = this.extractMetadataLabels(record.metadata);
        const definitionLabels = this.definitions.get(record.taskId)?.labels ?? [];
        const labelSet = new Set([record.label, ...(record.labels ?? []), ...metadataLabels, ...definitionLabels].filter((label) => typeof label === "string" && Boolean(label)));
        return values.some((value) => labelSet.has(value));
    }
    extractMetadataLabels(metadata) {
        if (!metadata)
            return [];
        const labels = metadata.labels;
        return Array.isArray(labels)
            ? labels.filter((label) => typeof label === "string" && Boolean(label))
            : [];
    }
}
exports.TaskRegistry = TaskRegistry;
exports.globalTaskRegistry = new TaskRegistry();
function resetGlobalTaskRegistry() {
    exports.globalTaskRegistry.clear();
}
function normalizeLabels(labels) {
    const seen = new Set();
    const result = [];
    for (const label of labels) {
        if (typeof label !== "string")
            continue;
        const trimmed = label.trim();
        if (!trimmed || seen.has(trimmed))
            continue;
        seen.add(trimmed);
        result.push(trimmed);
    }
    return result;
}
function normalizeLabelValue(label) {
    if (typeof label !== "string")
        return undefined;
    const trimmed = label.trim();
    return trimmed.length ? trimmed : undefined;
}
