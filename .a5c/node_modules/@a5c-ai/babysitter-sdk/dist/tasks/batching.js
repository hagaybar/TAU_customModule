"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildParallelBatch = buildParallelBatch;
exports.summarizeEffectAction = summarizeEffectAction;
exports.toParallelPendingPayload = toParallelPendingPayload;
const crypto_1 = require("crypto");
/**
 * Deduplicates EffectAction entries by effectId while preserving order and builds summaries.
 */
function buildParallelBatch(actions) {
    const seen = new Set();
    const deduped = [];
    for (const action of actions) {
        if (seen.has(action.effectId))
            continue;
        seen.add(action.effectId);
        deduped.push(action);
    }
    const annotated = assignParallelGroupHints(deduped);
    const summaries = annotated.map(summarizeEffectAction);
    return {
        actions: annotated,
        summaries,
    };
}
function summarizeEffectAction(action) {
    return {
        effectId: action.effectId,
        invocationKey: action.invocationKey,
        taskId: action.taskId,
        stepId: action.stepId,
        kind: action.kind,
        label: action.label,
        labels: action.labels ? [...action.labels] : undefined,
        taskDefRef: action.taskDefRef,
        inputsRef: action.inputsRef,
        requestedAt: action.requestedAt,
        metadata: action.taskDef?.metadata,
    };
}
function toParallelPendingPayload(batch) {
    return {
        effects: batch.summaries,
    };
}
function assignParallelGroupHints(actions) {
    if (actions.length <= 1) {
        return actions;
    }
    const hash = (0, crypto_1.createHash)("sha1");
    actions.forEach((action) => {
        hash.update(action.invocationKey ?? action.effectId);
        hash.update("|");
    });
    const parallelGroupId = hash.digest("hex").slice(0, 16);
    return actions.map((action) => ({
        ...action,
        schedulerHints: mergeSchedulerHints(action.schedulerHints, { parallelGroupId }),
    }));
}
function mergeSchedulerHints(base, extra) {
    return {
        ...(base ?? {}),
        ...extra,
    };
}
