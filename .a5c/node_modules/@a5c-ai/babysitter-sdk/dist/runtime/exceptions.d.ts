import { EffectAction, SerializedEffectError } from "./types";
import { type ParallelBatch } from "../tasks/batching";
export interface BabysitterErrorDetails {
    [key: string]: unknown;
}
export declare class BabysitterRuntimeError extends Error {
    readonly details?: BabysitterErrorDetails;
    constructor(name: string, message: string, details?: BabysitterErrorDetails);
}
export declare class BabysitterIntrinsicError extends BabysitterRuntimeError {
    readonly isIntrinsic = true;
    constructor(name: string, message: string, details?: BabysitterErrorDetails);
}
export declare class EffectRequestedError extends BabysitterIntrinsicError {
    readonly action: EffectAction;
    constructor(action: EffectAction);
}
export declare class EffectPendingError extends BabysitterIntrinsicError {
    readonly action: EffectAction;
    constructor(action: EffectAction);
}
export declare class ParallelPendingError extends BabysitterIntrinsicError {
    readonly batch: ParallelBatch;
    readonly effects: EffectAction[];
    constructor(batch: ParallelBatch);
}
export declare class InvocationCollisionError extends BabysitterRuntimeError {
    readonly invocationKey: string;
    constructor(invocationKey: string);
}
export declare class RunFailedError extends BabysitterRuntimeError {
    constructor(message: string, details?: BabysitterErrorDetails);
}
export declare class MissingProcessContextError extends BabysitterRuntimeError {
    constructor();
}
export declare class InvalidTaskDefinitionError extends BabysitterRuntimeError {
    constructor(reason: string);
}
export declare class InvalidSleepTargetError extends BabysitterRuntimeError {
    constructor(value: string | number);
}
export declare function isIntrinsicError(error: unknown): error is BabysitterIntrinsicError;
export declare function rehydrateSerializedError(data?: SerializedEffectError): Error;
//# sourceMappingURL=exceptions.d.ts.map