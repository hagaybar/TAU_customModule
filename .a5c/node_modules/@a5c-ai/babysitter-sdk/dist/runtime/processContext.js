"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProcessContext = createProcessContext;
exports.withProcessContext = withProcessContext;
exports.getActiveProcessContext = getActiveProcessContext;
exports.requireProcessContext = requireProcessContext;
const async_hooks_1 = require("async_hooks");
const task_1 = require("./intrinsics/task");
const breakpoint_1 = require("./intrinsics/breakpoint");
const sleep_1 = require("./intrinsics/sleep");
const orchestratorTask_1 = require("./intrinsics/orchestratorTask");
const hook_1 = require("./intrinsics/hook");
const dispatcher_1 = require("../hooks/dispatcher");
const parallel_1 = require("./intrinsics/parallel");
const exceptions_1 = require("./exceptions");
const contextStorage = new async_hooks_1.AsyncLocalStorage();
function createProcessContext(init) {
    const safeLogger = typeof init.logger === "function" ? init.logger : undefined;
    const internal = {
        ...init,
        logger: safeLogger,
        now: init.now ?? (() => new Date()),
    };
    const parallelHelpers = {
        all: (thunks) => (0, parallel_1.runParallelAll)(thunks),
        map: (items, fn) => (0, parallel_1.runParallelMap)(items, fn),
    };
    const processContext = {
        now: () => internal.now(),
        task: (task, args, options) => (0, task_1.runTaskIntrinsic)({
            task,
            args,
            invokeOptions: options,
            context: internal,
        }),
        breakpoint: (payload, options) => (0, breakpoint_1.runBreakpointIntrinsic)(payload, internal, options),
        sleepUntil: (target, options) => (0, sleep_1.runSleepIntrinsic)(target, internal, options),
        orchestratorTask: (payload, options) => (0, orchestratorTask_1.runOrchestratorTaskIntrinsic)(payload, internal, options),
        hook: (hookType, payload, options) => (0, hook_1.runHookIntrinsic)(hookType, payload, internal, options),
        parallel: parallelHelpers,
        // Always provide a callable logger to processes so `ctx.log(...)` never throws.
        // Dispatches the babysitter-log hook with a single string payload.
        log: (message) => {
            if (typeof message !== "string" || !message)
                return;
            void (0, dispatcher_1.callHook)({
                hookType: "babysitter-log",
                payload: message,
                cwd: internal.runDir,
            }).catch(() => {
                // Never let logging break an orchestration.
            });
        },
    };
    return {
        context: processContext,
        internalContext: internal,
    };
}
function withProcessContext(internal, fn) {
    return contextStorage.run(internal, () => Promise.resolve().then(fn));
}
function getActiveProcessContext() {
    return contextStorage.getStore();
}
function requireProcessContext() {
    const ctx = getActiveProcessContext();
    if (!ctx) {
        throw new exceptions_1.MissingProcessContextError();
    }
    return ctx;
}
