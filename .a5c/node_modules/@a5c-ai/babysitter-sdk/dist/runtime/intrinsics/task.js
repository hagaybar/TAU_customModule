"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTaskIntrinsic = runTaskIntrinsic;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const journal_1 = require("../../storage/journal");
const tasks_1 = require("../../storage/tasks");
const ulids_1 = require("../../storage/ulids");
const exceptions_1 = require("../exceptions");
const invocation_1 = require("../invocation");
const instrumentation_1 = require("../instrumentation");
const context_1 = require("../../tasks/context");
const registry_1 = require("../../tasks/registry");
const serializer_1 = require("../../tasks/serializer");
async function runTaskIntrinsic(options) {
    const { task } = options;
    if (!task || typeof task.build !== "function" || typeof task.id !== "string" || !task.id) {
        throw new exceptions_1.InvalidTaskDefinitionError("ctx.task requires a DefinedTask created via defineTask()");
    }
    const stepId = options.context.replayCursor.nextStepId();
    const invocation = (0, invocation_1.hashInvocationKey)({
        processId: options.context.processId,
        stepId,
        taskId: task.id,
    });
    const existing = options.context.effectIndex.getByInvocation(invocation.key);
    if (existing) {
        return handleExistingInvocation(existing, options);
    }
    return requestNewEffect(stepId, invocation.key, invocation.digest, options);
}
async function handleExistingInvocation(record, options) {
    if (record.status === "requested") {
        const taskDef = await ensureTaskDefinition(options.context.runDir, record);
        throw new exceptions_1.EffectPendingError(buildEffectAction(record, taskDef));
    }
    if (record.status === "resolved_error") {
        const error = record.error ? (0, exceptions_1.rehydrateSerializedError)(record.error) : new Error("Task failed");
        throw error;
    }
    const stored = await (0, tasks_1.readTaskResult)(options.context.runDir, record.effectId, record.resultRef ? normalizeRef(options.context.runDir, record.resultRef) : undefined);
    if (!stored) {
        throw new exceptions_1.RunFailedError(`Result for effect ${record.effectId} is missing from disk`, {
            effectId: record.effectId,
        });
    }
    if (stored.status !== "ok") {
        const err = stored.error ? (0, exceptions_1.rehydrateSerializedError)(stored.error) : new Error("Task reported failure");
        throw err;
    }
    const value = await resolveStoredResultValue(options.context.runDir, stored);
    return value;
}
async function requestNewEffect(stepId, invocationKey, invocationHash, options) {
    const effectId = (0, ulids_1.nextUlid)();
    const buildCtx = (0, context_1.createTaskBuildContext)({
        effectId,
        runId: options.context.runId,
        runDir: options.context.runDir,
        invocationKey,
        taskId: options.task.id,
        label: options.invokeOptions?.label,
    });
    const taskDef = await Promise.resolve(options.task.build(options.args, buildCtx));
    if (!taskDef || typeof taskDef.kind !== "string") {
        throw new exceptions_1.InvalidTaskDefinitionError(`Task ${options.task.id} did not provide a kind`);
    }
    const { taskRef: taskDefRef, inputsRef } = await (0, serializer_1.serializeAndWriteTaskDefinition)({
        runDir: options.context.runDir,
        effectId,
        taskId: options.task.id,
        invocationKey,
        stepId,
        task: taskDef,
        inputs: options.args,
    });
    const kind = taskDef.kind;
    const normalizedLabels = collectInvocationLabels(buildCtx, taskDef);
    const label = deriveEffectLabel(buildCtx, taskDef, normalizedLabels, options.task.id);
    const labelMetadata = normalizedLabels.length ? normalizedLabels : undefined;
    const eventPayload = {
        effectId,
        invocationKey,
        invocationHash,
        stepId,
        taskId: options.task.id,
        kind,
        label,
        taskDefRef,
        inputsRef,
        labels: labelMetadata,
    };
    const appendResult = await (0, journal_1.appendEvent)({
        runDir: options.context.runDir,
        eventType: "EFFECT_REQUESTED",
        event: eventPayload,
    });
    const syntheticEvent = {
        seq: appendResult.seq,
        ulid: appendResult.ulid,
        filename: appendResult.filename,
        path: appendResult.path,
        type: "EFFECT_REQUESTED",
        recordedAt: appendResult.recordedAt,
        data: eventPayload,
        checksum: appendResult.checksum,
    };
    try {
        options.context.effectIndex.applyEvent(syntheticEvent);
    }
    catch (error) {
        (0, instrumentation_1.emitRuntimeMetric)(options.context.logger, "invocation.collision", {
            invocationKey,
            effectId,
        });
        throw new exceptions_1.InvocationCollisionError(invocationKey);
    }
    registry_1.globalTaskRegistry.recordEffect({
        effectId,
        invocationKey,
        taskId: options.task.id,
        kind,
        label,
        labels: normalizedLabels,
        status: "pending",
        taskDefRef,
        inputsRef,
        metadata: taskDef.metadata,
        stepId,
        requestedAt: appendResult.recordedAt,
    });
    const actionRecord = {
        effectId,
        invocationKey,
        invocationHash,
        stepId,
        taskId: options.task.id,
        status: "requested",
        kind,
        label,
        labels: labelMetadata,
        taskDefRef,
        inputsRef,
        requestedAt: appendResult.recordedAt,
    };
    const action = buildEffectAction(actionRecord, taskDef);
    throw new exceptions_1.EffectRequestedError(action);
}
async function ensureTaskDefinition(runDir, record) {
    const stored = await (0, tasks_1.readTaskDefinition)(runDir, record.effectId);
    if (!stored) {
        throw new exceptions_1.RunFailedError(`Task definition missing for effect ${record.effectId}`, {
            effectId: record.effectId,
        });
    }
    return stored;
}
function buildEffectAction(record, taskDef) {
    const schedulerHints = deriveSchedulerHints(taskDef);
    return {
        effectId: record.effectId,
        invocationKey: record.invocationKey,
        kind: record.kind ?? taskDef.kind,
        label: record.label ?? record.labels?.[0] ?? taskDef.title,
        labels: record.labels ?? taskDef.labels,
        taskDef,
        taskId: record.taskId,
        stepId: record.stepId,
        taskDefRef: record.taskDefRef,
        inputsRef: record.inputsRef,
        requestedAt: record.requestedAt,
        schedulerHints,
    };
}
function deriveSchedulerHints(taskDef) {
    const hints = {};
    const sleepHint = extractSleepTarget(taskDef);
    if (typeof sleepHint === "number" && Number.isFinite(sleepHint)) {
        hints.sleepUntilEpochMs = sleepHint;
    }
    return Object.keys(hints).length ? hints : undefined;
}
function extractSleepTarget(taskDef) {
    if (typeof taskDef.sleep?.targetEpochMs === "number") {
        return taskDef.sleep.targetEpochMs;
    }
    const metadataTarget = taskDef.metadata?.targetEpochMs;
    return typeof metadataTarget === "number" ? metadataTarget : undefined;
}
function normalizeRef(runDir, ref) {
    return path_1.default.isAbsolute(ref) ? ref : path_1.default.join(runDir, ref);
}
async function resolveStoredResultValue(runDir, stored) {
    if (stored.result !== undefined) {
        return stored.result;
    }
    if (stored.value !== undefined) {
        return stored.value;
    }
    if (stored.resultRef) {
        const absolute = normalizeRef(runDir, stored.resultRef);
        const raw = await fs_1.promises.readFile(absolute, "utf8");
        return JSON.parse(raw);
    }
    throw new exceptions_1.RunFailedError("Result payload missing data", { effectId: stored.effectId });
}
function collectInvocationLabels(ctx, taskDef) {
    const combined = [];
    const addLabels = (values) => {
        if (!Array.isArray(values))
            return;
        combined.push(...values);
    };
    addLabels(ctx.labels);
    addLabels(taskDef.labels);
    return dedupeLabels(combined);
}
function dedupeLabels(values) {
    const seen = new Set();
    const normalized = [];
    for (const value of values) {
        if (typeof value !== "string")
            continue;
        const trimmed = value.trim();
        if (!trimmed || seen.has(trimmed))
            continue;
        seen.add(trimmed);
        normalized.push(trimmed);
    }
    return normalized;
}
function deriveEffectLabel(ctx, taskDef, labels, fallbackTaskId) {
    return ctx.label ?? labels[0] ?? taskDef.title ?? fallbackTaskId;
}
