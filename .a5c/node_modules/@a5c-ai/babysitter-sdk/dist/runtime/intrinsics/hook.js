"use strict";
/**
 * Hook Intrinsic
 * Allows process files to call hooks directly
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runHookIntrinsic = runHookIntrinsic;
const dispatcher_1 = require("../../hooks/dispatcher");
/**
 * Run a hook from within a process
 * This is exposed as ctx.hook() in process files
 */
async function runHookIntrinsic(hookType, payload, context, options) {
    // Add timestamp if not present
    const fullPayload = {
        ...payload,
        hookType,
        timestamp: new Date().toISOString(),
    };
    // Add runId from context if not in payload
    if (!("runId" in fullPayload) && context.runId) {
        fullPayload.runId = context.runId;
    }
    // Log the hook invocation
    const label = options?.label || `hook:${hookType}`;
    context.logger?.(`[${label}] Calling hook: ${hookType}`);
    try {
        const result = await (0, dispatcher_1.callHook)({
            hookType,
            payload: fullPayload,
            cwd: context.runDir,
            timeout: options?.timeout,
            throwOnFailure: options?.throwOnFailure,
        });
        // Log the result
        const hookCount = result.executedHooks.length;
        const successCount = result.executedHooks.filter((h) => h.status === "success").length;
        context.logger?.(`[${label}] Hook execution complete: ${successCount}/${hookCount} hooks succeeded`);
        return result;
    }
    catch (error) {
        context.logger?.(`[${label}] Hook execution failed: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
    }
}
