"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSleepIntrinsic = runSleepIntrinsic;
const exceptions_1 = require("../exceptions");
const task_1 = require("./task");
const SLEEP_TASK_ID = "__sdk.sleep";
const sleepTask = {
    id: SLEEP_TASK_ID,
    build(args) {
        return {
            kind: "sleep",
            title: `sleep:${args.iso}`,
            sleep: {
                iso: args.iso,
                targetEpochMs: args.targetEpochMs,
            },
            metadata: {
                targetEpochMs: args.targetEpochMs,
                iso: args.iso,
            },
        };
    },
};
async function runSleepIntrinsic(target, context, options) {
    const epoch = normalizeSleepTarget(target);
    if (!Number.isFinite(epoch) || epoch < 0) {
        throw new exceptions_1.InvalidSleepTargetError(target);
    }
    const nowMs = context.now().getTime();
    if (epoch <= nowMs) {
        return;
    }
    const iso = new Date(epoch).toISOString();
    const label = options?.label ?? `sleep:${iso}`;
    const invokeOptions = { ...options, label };
    try {
        await (0, task_1.runTaskIntrinsic)({
            task: sleepTask,
            args: { targetEpochMs: epoch, iso },
            invokeOptions,
            context,
        });
    }
    catch (error) {
        if (shouldShortCircuitPending(error, nowMs)) {
            return;
        }
        throw error;
    }
}
function normalizeSleepTarget(target) {
    if (typeof target === "number") {
        return target;
    }
    if (typeof target === "string") {
        const parsed = Date.parse(target);
        return Number.isNaN(parsed) ? NaN : parsed;
    }
    return NaN;
}
function shouldShortCircuitPending(error, nowMs) {
    if (!(error instanceof exceptions_1.EffectPendingError)) {
        return false;
    }
    const metadata = error.action.taskDef?.metadata;
    if (typeof metadata?.targetEpochMs !== "number") {
        return false;
    }
    return metadata.targetEpochMs <= nowMs;
}
