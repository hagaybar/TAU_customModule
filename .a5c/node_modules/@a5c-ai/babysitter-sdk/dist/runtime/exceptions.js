"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidSleepTargetError = exports.InvalidTaskDefinitionError = exports.MissingProcessContextError = exports.RunFailedError = exports.InvocationCollisionError = exports.ParallelPendingError = exports.EffectPendingError = exports.EffectRequestedError = exports.BabysitterIntrinsicError = exports.BabysitterRuntimeError = void 0;
exports.isIntrinsicError = isIntrinsicError;
exports.rehydrateSerializedError = rehydrateSerializedError;
const batching_1 = require("../tasks/batching");
class BabysitterRuntimeError extends Error {
    details;
    constructor(name, message, details) {
        super(message);
        this.name = name;
        this.details = details;
    }
}
exports.BabysitterRuntimeError = BabysitterRuntimeError;
class BabysitterIntrinsicError extends BabysitterRuntimeError {
    isIntrinsic = true;
    constructor(name, message, details) {
        super(name, message, details);
    }
}
exports.BabysitterIntrinsicError = BabysitterIntrinsicError;
class EffectRequestedError extends BabysitterIntrinsicError {
    action;
    constructor(action) {
        super("EffectRequestedError", `Effect ${action.effectId} requested`, { action });
        this.action = action;
    }
}
exports.EffectRequestedError = EffectRequestedError;
class EffectPendingError extends BabysitterIntrinsicError {
    action;
    constructor(action) {
        super("EffectPendingError", `Effect ${action.effectId} pending`, { action });
        this.action = action;
    }
}
exports.EffectPendingError = EffectPendingError;
class ParallelPendingError extends BabysitterIntrinsicError {
    batch;
    effects;
    constructor(batch) {
        super("ParallelPendingError", "One or more parallel invocations are pending", {
            payload: (0, batching_1.toParallelPendingPayload)(batch),
            effects: batch.actions,
        });
        this.batch = batch;
        this.effects = batch.actions;
    }
}
exports.ParallelPendingError = ParallelPendingError;
class InvocationCollisionError extends BabysitterRuntimeError {
    invocationKey;
    constructor(invocationKey) {
        super("InvocationCollisionError", `Invocation key ${invocationKey} is already in use within this run`, { invocationKey });
        this.invocationKey = invocationKey;
    }
}
exports.InvocationCollisionError = InvocationCollisionError;
class RunFailedError extends BabysitterRuntimeError {
    constructor(message, details) {
        super("RunFailedError", message, details);
    }
}
exports.RunFailedError = RunFailedError;
class MissingProcessContextError extends BabysitterRuntimeError {
    constructor() {
        super("MissingProcessContextError", "No active process context found on the current async call stack");
    }
}
exports.MissingProcessContextError = MissingProcessContextError;
class InvalidTaskDefinitionError extends BabysitterRuntimeError {
    constructor(reason) {
        super("InvalidTaskDefinitionError", reason);
    }
}
exports.InvalidTaskDefinitionError = InvalidTaskDefinitionError;
class InvalidSleepTargetError extends BabysitterRuntimeError {
    constructor(value) {
        super("InvalidSleepTargetError", `Invalid sleep target: ${value}`);
    }
}
exports.InvalidSleepTargetError = InvalidSleepTargetError;
function isIntrinsicError(error) {
    return Boolean(error && typeof error === "object" && error.isIntrinsic);
}
function rehydrateSerializedError(data) {
    const name = data?.name ?? "TaskError";
    const message = data?.message ?? "Task failed";
    const err = new Error(message);
    err.name = name;
    if (data?.stack) {
        err.stack = data.stack;
    }
    if (data?.data !== undefined) {
        err.data = data.data;
    }
    return err;
}
