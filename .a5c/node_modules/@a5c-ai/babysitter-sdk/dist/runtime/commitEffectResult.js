"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commitEffectResult = commitEffectResult;
const journal_1 = require("../storage/journal");
const lock_1 = require("../storage/lock");
const effectIndex_1 = require("./replay/effectIndex");
const exceptions_1 = require("./exceptions");
const errorUtils_1 = require("./errorUtils");
const instrumentation_1 = require("./instrumentation");
const registry_1 = require("../tasks/registry");
const serializer_1 = require("../tasks/serializer");
async function commitEffectResult(options) {
    return await (0, lock_1.withRunLock)(options.runDir, "runtime:commitEffectResult", async () => {
        guardResultPayload(options);
        const effectIndex = await (0, effectIndex_1.buildEffectIndex)({ runDir: options.runDir });
        const record = effectIndex.getByEffectId(options.effectId);
        if (!record) {
            logCommitFailure(options, "unknown_effect");
            throw new exceptions_1.RunFailedError(`Unknown effectId ${options.effectId}`);
        }
        if (record.status !== "requested") {
            logCommitFailure(options, "already_resolved", { currentStatus: record.status });
            throw new exceptions_1.RunFailedError(`Effect ${options.effectId} is already resolved`);
        }
        ensureInvocationKeyMatches(options, record);
        const resultPayload = buildResultPayload(options);
        const { resultRef, stdoutRef: writtenStdoutRef, stderrRef: writtenStderrRef } = await (0, serializer_1.serializeAndWriteTaskResult)({
            runDir: options.runDir,
            effectId: options.effectId,
            taskId: requireTaskId(record),
            invocationKey: record.invocationKey,
            payload: resultPayload,
        });
        const stdoutRef = resultPayload.stdoutRef ?? writtenStdoutRef;
        const stderrRef = resultPayload.stderrRef ?? writtenStderrRef;
        const eventError = resultPayload.status === "error" ? resultPayload.error : undefined;
        const resolvedEvent = await (0, journal_1.appendEvent)({
            runDir: options.runDir,
            eventType: "EFFECT_RESOLVED",
            event: {
                effectId: options.effectId,
                status: options.result.status,
                resultRef,
                error: eventError,
                stdoutRef,
                stderrRef,
                startedAt: resultPayload.startedAt,
                finishedAt: resultPayload.finishedAt,
            },
        });
        registry_1.globalTaskRegistry.resolveEffect(options.effectId, {
            status: options.result.status === "ok" ? "resolved_ok" : "resolved_error",
            resultRef,
            stdoutRef,
            stderrRef,
            resolvedAt: resolvedEvent.recordedAt,
        });
        (0, instrumentation_1.emitRuntimeMetric)(options.logger, "commit.effect", {
            effectId: options.effectId,
            invocationKey: record.invocationKey,
            status: options.result.status,
            runDir: options.runDir,
            hasStdout: Boolean(stdoutRef),
            hasStderr: Boolean(stderrRef),
        });
        return {
            resultRef,
            stdoutRef: stdoutRef ?? undefined,
            stderrRef: stderrRef ?? undefined,
            startedAt: resultPayload.startedAt,
            finishedAt: resultPayload.finishedAt,
        };
    });
}
function ensureInvocationKeyMatches(options, record) {
    if (!options.invocationKey)
        return;
    if (options.invocationKey === record.invocationKey) {
        return;
    }
    logCommitFailure(options, "invocation_mismatch", {
        expectedInvocationKey: record.invocationKey,
        providedInvocationKey: options.invocationKey,
    });
    throw new exceptions_1.RunFailedError(`Invocation key mismatch for effect ${options.effectId}`, {
        effectId: options.effectId,
        expectedInvocationKey: record.invocationKey,
        providedInvocationKey: options.invocationKey,
    });
}
function serializeEffectError(error) {
    return (0, errorUtils_1.toSerializedEffectError)(error);
}
function guardResultPayload(options) {
    try {
        validateResultPayload(options);
    }
    catch (error) {
        logCommitFailure(options, "invalid_payload", {
            message: error instanceof Error ? error.message : String(error),
        });
        throw error;
    }
}
function validateResultPayload(options) {
    if (options.result.status === "ok" && options.result.error !== undefined) {
        throw new exceptions_1.RunFailedError("Cannot provide an error payload when result status is 'ok'");
    }
    if (options.result.status === "error" && options.result.error === undefined) {
        throw new exceptions_1.RunFailedError("Missing error payload for result status 'error'");
    }
    if (options.result.stdout !== undefined && typeof options.result.stdout !== "string") {
        throw new exceptions_1.RunFailedError("stdout must be a string when provided");
    }
    if (options.result.stderr !== undefined && typeof options.result.stderr !== "string") {
        throw new exceptions_1.RunFailedError("stderr must be a string when provided");
    }
    if (options.result.stdoutRef !== undefined && typeof options.result.stdoutRef !== "string") {
        throw new exceptions_1.RunFailedError("stdoutRef must be a string when provided");
    }
    if (options.result.stderrRef !== undefined && typeof options.result.stderrRef !== "string") {
        throw new exceptions_1.RunFailedError("stderrRef must be a string when provided");
    }
    if (options.result.startedAt !== undefined && typeof options.result.startedAt !== "string") {
        throw new exceptions_1.RunFailedError("startedAt must be an ISO timestamp string when provided");
    }
    if (options.result.finishedAt !== undefined && typeof options.result.finishedAt !== "string") {
        throw new exceptions_1.RunFailedError("finishedAt must be an ISO timestamp string when provided");
    }
    if (options.result.metadata !== undefined &&
        (options.result.metadata === null || typeof options.result.metadata !== "object" || Array.isArray(options.result.metadata))) {
        throw new exceptions_1.RunFailedError("metadata must be a JsonRecord when provided");
    }
}
function logCommitFailure(options, reason, extra = {}) {
    (0, instrumentation_1.emitRuntimeMetric)(options.logger, "commit.effect", {
        effectId: options.effectId,
        status: "rejected",
        reason,
        runDir: options.runDir,
        invocationKey: options.invocationKey,
        ...extra,
    });
}
function buildResultPayload(options) {
    const base = {
        stdout: options.result.stdout,
        stderr: options.result.stderr,
        stdoutRef: options.result.stdoutRef,
        stderrRef: options.result.stderrRef,
        startedAt: options.result.startedAt,
        finishedAt: options.result.finishedAt,
        metadata: options.result.metadata,
    };
    if (options.result.status === "ok") {
        return {
            status: "ok",
            result: options.result.value,
            ...base,
        };
    }
    return {
        status: "error",
        error: serializeEffectError(options.result.error),
        ...base,
    };
}
function requireTaskId(record) {
    if (record.taskId) {
        return record.taskId;
    }
    throw new exceptions_1.RunFailedError(`Effect ${record.effectId} is missing task id metadata`, {
        effectId: record.effectId,
    });
}
