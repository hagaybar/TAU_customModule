"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EffectIndex = void 0;
exports.buildEffectIndex = buildEffectIndex;
const journal_1 = require("../../storage/journal");
const exceptions_1 = require("../exceptions");
const errorUtils_1 = require("../errorUtils");
class EffectIndex {
    runDir;
    byInvocation = new Map();
    byEffectId = new Map();
    journalHead;
    initialized = false;
    constructor(runDir) {
        this.runDir = runDir;
    }
    static async build(options) {
        const events = options.events ?? (await loadJournalSafe(options.runDir));
        const index = new EffectIndex(options.runDir);
        index.applyEvents(events);
        index.initialized = true;
        return index;
    }
    applyEvents(events) {
        events.forEach((event, idx) => {
            const expectedSeq = idx + 1;
            this.applyEvent(event, expectedSeq);
        });
    }
    applyEvent(event, expectedSeq) {
        this.validateSequence(event, expectedSeq);
        const type = event.type;
        switch (type) {
            case "RUN_CREATED":
            case "RUN_COMPLETED":
            case "RUN_FAILED":
                return;
            case "EFFECT_REQUESTED":
                this.handleEffectRequested(event);
                return;
            case "EFFECT_RESOLVED":
                this.handleEffectResolved(event);
                return;
            default:
                throw new exceptions_1.RunFailedError(`Unknown journal event type '${event.type}'`, {
                    path: event.path,
                    seq: event.seq,
                });
        }
    }
    getByInvocation(invocationKey) {
        return this.byInvocation.get(invocationKey);
    }
    getByEffectId(effectId) {
        return this.byEffectId.get(effectId);
    }
    listEffects() {
        return Array.from(this.byEffectId.values());
    }
    listPendingEffects() {
        return this.listEffects().filter((record) => record.status === "requested");
    }
    getJournalHead() {
        return this.journalHead;
    }
    validateSequence(event, expectedSeq) {
        if (!Number.isFinite(event.seq) || event.seq <= 0) {
            throw new exceptions_1.RunFailedError(`Invalid journal sequence number in ${event.filename}`, {
                path: event.path,
            });
        }
        if (typeof event.ulid !== "string" || !event.ulid) {
            throw new exceptions_1.RunFailedError(`Invalid ULID on journal event ${event.filename}`, {
                path: event.path,
            });
        }
        if (!this.journalHead) {
            if (event.seq !== (expectedSeq ?? 1)) {
                throw new exceptions_1.RunFailedError(`Journal seq mismatch at ${event.filename} (expected 1, got ${event.seq})`, {
                    path: event.path,
                });
            }
            this.journalHead = { seq: event.seq, ulid: event.ulid };
            return;
        }
        const nextSeq = this.journalHead.seq + 1;
        const shouldMatch = expectedSeq ?? nextSeq;
        if (event.seq !== shouldMatch) {
            throw new exceptions_1.RunFailedError(`Journal sequence gap detected at ${event.filename} (expected ${shouldMatch}, got ${event.seq})`, { path: event.path });
        }
        if (event.seq <= this.journalHead.seq) {
            throw new exceptions_1.RunFailedError(`Journal sequence regression at ${event.filename} (prev ${this.journalHead.seq}, got ${event.seq})`, { path: event.path });
        }
        if (event.ulid <= this.journalHead.ulid) {
            throw new exceptions_1.RunFailedError(`Journal ULID order regression at ${event.filename} (${event.ulid} <= ${this.journalHead.ulid})`, { path: event.path });
        }
        this.journalHead = { seq: event.seq, ulid: event.ulid };
    }
    handleEffectRequested(event) {
        const payload = this.expectObject(event, "EFFECT_REQUESTED");
        const effectId = this.expectString(payload.effectId, "effectId", event);
        const invocationKey = this.expectString(payload.invocationKey, "invocationKey", event);
        const stepId = this.expectString(payload.stepId, "stepId", event);
        const taskId = this.expectString(payload.taskId, "taskId", event);
        const taskDefRef = this.expectString(payload.taskDefRef, "taskDefRef", event);
        const inputsRef = this.expectOptionalString(payload.inputsRef, "inputsRef", event);
        const labels = this.normalizeLabelArray(payload.labels, event);
        if (this.byEffectId.has(effectId)) {
            throw new exceptions_1.RunFailedError(`Duplicate effectId detected: ${effectId}`, { path: event.path });
        }
        if (this.byInvocation.has(invocationKey)) {
            throw new exceptions_1.RunFailedError(`Duplicate invocation key detected: ${invocationKey}`, {
                path: event.path,
            });
        }
        const record = {
            effectId,
            invocationKey,
            invocationHash: payload.invocationHash,
            stepId,
            taskId,
            status: "requested",
            kind: payload.kind,
            label: payload.label,
            labels,
            taskDefRef,
            inputsRef,
            requestedAt: event.recordedAt,
        };
        this.byInvocation.set(record.invocationKey, record);
        this.byEffectId.set(record.effectId, record);
    }
    handleEffectResolved(event) {
        const payload = this.expectObject(event, "EFFECT_RESOLVED");
        const effectId = this.expectString(payload.effectId, "effectId", event);
        if (!payload.status) {
            throw new exceptions_1.RunFailedError("Malformed EFFECT_RESOLVED event missing status", { path: event.path });
        }
        if (payload.status !== "ok" && payload.status !== "error") {
            throw new exceptions_1.RunFailedError(`Unknown EFFECT_RESOLVED status '${String(payload.status)}'`, { path: event.path });
        }
        if (payload.resultRef && typeof payload.resultRef !== "string") {
            throw new exceptions_1.RunFailedError("Malformed EFFECT_RESOLVED event resultRef", { path: event.path });
        }
        if (payload.stdoutRef && typeof payload.stdoutRef !== "string") {
            throw new exceptions_1.RunFailedError("Malformed EFFECT_RESOLVED stdoutRef", { path: event.path });
        }
        if (payload.stderrRef && typeof payload.stderrRef !== "string") {
            throw new exceptions_1.RunFailedError("Malformed EFFECT_RESOLVED stderrRef", { path: event.path });
        }
        const record = this.byEffectId.get(effectId);
        if (!record) {
            throw new exceptions_1.RunFailedError(`EFFECT_RESOLVED references unknown effectId ${effectId}`, {
                path: event.path,
            });
        }
        if (record.status !== "requested") {
            throw new exceptions_1.RunFailedError(`Effect ${effectId} already resolved`, { path: event.path });
        }
        const status = payload.status === "ok" ? "resolved_ok" : "resolved_error";
        record.status = status;
        record.resultRef = payload.resultRef;
        record.error = payload.error;
        record.stdoutRef = payload.stdoutRef;
        record.stderrRef = payload.stderrRef;
        record.resolvedAt = event.recordedAt;
    }
    expectObject(event, type) {
        if (!event?.data || typeof event.data !== "object") {
            throw new exceptions_1.RunFailedError(`Malformed ${type} event payload`, { path: event.path });
        }
        return event.data;
    }
    expectString(value, field, event) {
        if (typeof value !== "string" || value.length === 0) {
            throw new exceptions_1.RunFailedError(`Malformed journal event missing ${field}`, {
                path: event.path,
            });
        }
        return value;
    }
    expectOptionalString(value, field, event) {
        if (value === undefined)
            return undefined;
        if (typeof value !== "string" || value.length === 0) {
            throw new exceptions_1.RunFailedError(`Malformed journal event ${field}`, {
                path: event.path,
            });
        }
        return value;
    }
    normalizeLabelArray(value, event) {
        if (value === undefined)
            return undefined;
        if (!Array.isArray(value)) {
            throw new exceptions_1.RunFailedError("Malformed EFFECT_REQUESTED labels payload", { path: event.path });
        }
        const seen = new Set();
        const labels = [];
        for (const entry of value) {
            if (typeof entry !== "string") {
                throw new exceptions_1.RunFailedError("Malformed EFFECT_REQUESTED labels entry", { path: event.path });
            }
            const trimmed = entry.trim();
            if (!trimmed || seen.has(trimmed))
                continue;
            seen.add(trimmed);
            labels.push(trimmed);
        }
        return labels.length ? labels : undefined;
    }
}
exports.EffectIndex = EffectIndex;
async function loadJournalSafe(runDir) {
    try {
        return await (0, journal_1.loadJournal)(runDir);
    }
    catch (error) {
        throw normalizeJournalError(error, runDir);
    }
}
function normalizeJournalError(error, runDir) {
    if (error instanceof exceptions_1.RunFailedError)
        return error;
    const err = error;
    if (err?.code === "JOURNAL_PARSE_FAILED") {
        return new exceptions_1.RunFailedError("Failed to parse journal event", {
            path: err.path,
            runDir,
            error: err.message,
        });
    }
    const serialized = (0, errorUtils_1.serializeUnknownError)(err);
    return new exceptions_1.RunFailedError("Failed to load journal for replay", {
        runDir,
        error: serialized,
    });
}
async function buildEffectIndex(options) {
    return EffectIndex.build(options);
}
