"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STATE_CACHE_SCHEMA_VERSION = void 0;
exports.readStateCache = readStateCache;
exports.writeStateCache = writeStateCache;
exports.journalHeadsEqual = journalHeadsEqual;
exports.createStateCacheSnapshot = createStateCacheSnapshot;
exports.normalizeJournalHead = normalizeJournalHead;
exports.normalizeSnapshot = normalizeSnapshot;
exports.rebuildStateCache = rebuildStateCache;
const fs_1 = require("fs");
const paths_1 = require("../../storage/paths");
const atomic_1 = require("../../storage/atomic");
const effectIndex_1 = require("./effectIndex");
const clock_1 = require("../../storage/clock");
exports.STATE_CACHE_SCHEMA_VERSION = "2026.01.state-cache";
async function readStateCache(runDir) {
    const stateFile = (0, paths_1.getStateFile)(runDir);
    try {
        const raw = await fs_1.promises.readFile(stateFile, "utf8");
        const parsed = JSON.parse(raw);
        return normalizeSnapshot(parsed);
    }
    catch (error) {
        const err = error;
        if (err.code === "ENOENT") {
            return null;
        }
        throw error;
    }
}
async function writeStateCache(runDir, snapshot) {
    const stateDir = (0, paths_1.getStateDir)(runDir);
    await fs_1.promises.mkdir(stateDir, { recursive: true });
    const stateFile = (0, paths_1.getStateFile)(runDir);
    await (0, atomic_1.writeFileAtomic)(stateFile, JSON.stringify(snapshot, null, 2) + "\n");
}
function journalHeadsEqual(a, b) {
    if (!a && !b)
        return true;
    if (!a || !b)
        return false;
    if (a.seq !== b.seq || a.ulid !== b.ulid)
        return false;
    if (a.checksum && b.checksum && a.checksum !== b.checksum)
        return false;
    return true;
}
function createStateCacheSnapshot(journalHeadOrOptions) {
    const options = journalHeadOrOptions && isJournalHeadLike(journalHeadOrOptions)
        ? { journalHead: journalHeadOrOptions }
        : journalHeadOrOptions ?? {};
    return {
        schemaVersion: options.schemaVersion ?? exports.STATE_CACHE_SCHEMA_VERSION,
        savedAt: options.savedAt ?? (0, clock_1.getClockIsoString)(),
        journalHead: options.journalHead ?? null,
        stateVersion: options.stateVersion ?? 0,
        effectsByInvocation: options.effectsByInvocation ?? {},
        pendingEffectsByKind: options.pendingEffectsByKind ?? {},
        rebuildReason: options.rebuildReason ?? null,
    };
}
function normalizeJournalHead(raw) {
    if (raw === null || raw === undefined)
        return raw;
    if (!isPlainObject(raw))
        return undefined;
    const seq = Number(raw.seq);
    const ulid = raw.ulid;
    if (!Number.isFinite(seq) || typeof ulid !== "string" || !ulid) {
        return undefined;
    }
    const checksum = typeof raw.checksum === "string" && raw.checksum ? raw.checksum : undefined;
    return { seq, ulid, checksum };
}
function normalizeSnapshot(raw) {
    if (!isPlainObject(raw)) {
        throw new Error("Invalid state cache snapshot");
    }
    const journalHead = raw.journalHead === null ? null : normalizeJournalHead(raw.journalHead ?? undefined) ?? null;
    const effectsByInvocation = normalizeEffectSummaryMap(raw.effectsByInvocation);
    const pendingEffectsByKind = normalizePendingEffects(raw.pendingEffectsByKind);
    const savedAt = typeof raw.savedAt === "string" ? raw.savedAt : (0, clock_1.getClockIsoString)();
    const rebuildReason = raw.rebuildReason === null
        ? null
        : typeof raw.rebuildReason === "string"
            ? raw.rebuildReason
            : null;
    const stateVersion = typeof raw.stateVersion === "number" && Number.isFinite(raw.stateVersion) ? raw.stateVersion : 0;
    return createStateCacheSnapshot({
        schemaVersion: typeof raw.schemaVersion === "string" ? raw.schemaVersion : exports.STATE_CACHE_SCHEMA_VERSION,
        savedAt,
        journalHead,
        stateVersion,
        effectsByInvocation,
        pendingEffectsByKind,
        rebuildReason,
    });
}
async function rebuildStateCache(runDir, opts) {
    const effectIndex = opts?.effectIndex ??
        (await (0, effectIndex_1.buildEffectIndex)({
            runDir,
        }));
    const journalHead = effectIndex.getJournalHead() ?? null;
    const stateVersion = journalHead?.seq ?? 0;
    const effectsByInvocation = deriveEffectsByInvocation(effectIndex);
    const pendingEffectsByKind = derivePendingByKind(effectIndex);
    const snapshot = createStateCacheSnapshot({
        journalHead,
        stateVersion,
        effectsByInvocation,
        pendingEffectsByKind,
        rebuildReason: opts?.reason ?? null,
    });
    await writeStateCache(runDir, snapshot);
    return snapshot;
}
function deriveEffectsByInvocation(effectIndex) {
    const summaries = {};
    effectIndex.listEffects().forEach((record) => {
        summaries[record.invocationKey] = summarizeEffect(record);
    });
    return summaries;
}
function summarizeEffect(record) {
    const summary = {
        effectId: record.effectId,
        invocationKey: record.invocationKey,
        status: record.status,
    };
    if (record.kind)
        summary.kind = record.kind;
    if (record.label)
        summary.label = record.label;
    if (record.taskId)
        summary.taskId = record.taskId;
    if (record.stepId)
        summary.stepId = record.stepId;
    if (record.requestedAt)
        summary.requestedAt = record.requestedAt;
    if (record.resolvedAt)
        summary.resolvedAt = record.resolvedAt;
    return summary;
}
function derivePendingByKind(effectIndex) {
    const totals = {};
    effectIndex.listPendingEffects().forEach((record) => {
        const key = record.kind ?? "unknown";
        totals[key] = (totals[key] ?? 0) + 1;
    });
    return totals;
}
function normalizeEffectSummaryMap(raw) {
    if (!isPlainObject(raw))
        return {};
    const summaries = {};
    for (const [key, value] of Object.entries(raw)) {
        const summary = normalizeDerivedEffectSummary(value);
        if (summary) {
            summaries[key] = summary;
        }
    }
    return summaries;
}
function normalizeDerivedEffectSummary(raw) {
    if (!isPlainObject(raw))
        return undefined;
    const effectId = typeof raw.effectId === "string" ? raw.effectId : undefined;
    const invocationKey = typeof raw.invocationKey === "string" ? raw.invocationKey : undefined;
    const status = isEffectStatus(raw.status) ? raw.status : undefined;
    if (!effectId || !invocationKey || !status) {
        return undefined;
    }
    const summary = { effectId, invocationKey, status };
    if (typeof raw.kind === "string")
        summary.kind = raw.kind;
    if (typeof raw.label === "string")
        summary.label = raw.label;
    if (typeof raw.taskId === "string")
        summary.taskId = raw.taskId;
    if (typeof raw.stepId === "string")
        summary.stepId = raw.stepId;
    if (typeof raw.requestedAt === "string")
        summary.requestedAt = raw.requestedAt;
    if (typeof raw.resolvedAt === "string")
        summary.resolvedAt = raw.resolvedAt;
    return summary;
}
function normalizePendingEffects(raw) {
    if (!isPlainObject(raw))
        return {};
    const totals = {};
    for (const [key, value] of Object.entries(raw)) {
        if (typeof value === "number" && Number.isFinite(value)) {
            totals[key] = value;
        }
    }
    return totals;
}
function isPlainObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isEffectStatus(value) {
    return value === "requested" || value === "resolved_ok" || value === "resolved_error";
}
function isJournalHeadLike(value) {
    if (!isPlainObject(value))
        return false;
    return Number.isFinite(value.seq) && typeof value.ulid === "string" && value.ulid.length > 0;
}
