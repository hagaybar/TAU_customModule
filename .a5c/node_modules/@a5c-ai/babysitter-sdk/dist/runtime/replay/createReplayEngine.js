"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReplayEngine = createReplayEngine;
const runFiles_1 = require("../../storage/runFiles");
const effectIndex_1 = require("./effectIndex");
const replayCursor_1 = require("./replayCursor");
const processContext_1 = require("../processContext");
const constants_1 = require("../constants");
const exceptions_1 = require("../exceptions");
const stateCache_1 = require("./stateCache");
async function createReplayEngine(options) {
    const metadata = await (0, runFiles_1.readRunMetadata)(options.runDir);
    ensureCompatibleLayout(metadata.layoutVersion, options.runDir);
    const inputs = await (0, runFiles_1.readRunInputs)(options.runDir);
    const effectIndex = await (0, effectIndex_1.buildEffectIndex)({ runDir: options.runDir });
    const { snapshot: stateCacheSnapshot, rebuildMeta: stateRebuild } = await resolveStateCacheSnapshot({
        runDir: options.runDir,
        effectIndex,
    });
    const replayCursor = new replayCursor_1.ReplayCursor();
    const processId = metadata.processId ?? metadata.request ?? metadata.runId;
    const { context, internalContext } = (0, processContext_1.createProcessContext)({
        runId: metadata.runId,
        runDir: options.runDir,
        processId,
        effectIndex,
        replayCursor,
        now: options.now,
        logger: options.logger,
    });
    return {
        runId: metadata.runId,
        runDir: options.runDir,
        metadata,
        inputs,
        effectIndex,
        replayCursor,
        context,
        internalContext,
        stateCache: stateCacheSnapshot,
        stateRebuild,
    };
}
async function resolveStateCacheSnapshot({ runDir, effectIndex, }) {
    let existingSnapshot = null;
    let corrupted = false;
    try {
        existingSnapshot = await (0, stateCache_1.readStateCache)(runDir);
    }
    catch {
        corrupted = true;
    }
    if (corrupted || !existingSnapshot) {
        const reason = corrupted ? "corrupt_cache" : "missing_cache";
        const rebuilt = await (0, stateCache_1.rebuildStateCache)(runDir, { effectIndex, reason });
        return { snapshot: rebuilt, rebuildMeta: { reason, previous: null } };
    }
    const journalHead = effectIndex.getJournalHead() ?? null;
    if (!(0, stateCache_1.journalHeadsEqual)(existingSnapshot.journalHead, journalHead)) {
        const rebuilt = await (0, stateCache_1.rebuildStateCache)(runDir, {
            effectIndex,
            reason: "journal_mismatch",
        });
        return {
            snapshot: rebuilt,
            rebuildMeta: { reason: "journal_mismatch", previous: existingSnapshot.journalHead ?? null },
        };
    }
    return { snapshot: existingSnapshot, rebuildMeta: null };
}
function ensureCompatibleLayout(layoutVersion, runDir) {
    if (!layoutVersion) {
        throw new exceptions_1.RunFailedError("Run metadata is missing layoutVersion", { runDir });
    }
    if (layoutVersion !== constants_1.replaySchemaVersion) {
        throw new exceptions_1.RunFailedError("Run layout version is not supported by this runtime", {
            expected: constants_1.replaySchemaVersion,
            actual: layoutVersion,
            runDir,
        });
    }
}
