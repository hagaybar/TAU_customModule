"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.orchestrateIteration = orchestrateIteration;
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
const journal_1 = require("../storage/journal");
const runFiles_1 = require("../storage/runFiles");
const lock_1 = require("../storage/lock");
const createReplayEngine_1 = require("./replay/createReplayEngine");
const processContext_1 = require("./processContext");
const exceptions_1 = require("./exceptions");
const errorUtils_1 = require("./errorUtils");
const instrumentation_1 = require("./instrumentation");
const runtime_1 = require("./hooks/runtime");
// Use an indirect dynamic import so TypeScript does not downlevel to require() in CommonJS builds.
// Vitest executes modules inside a VM context that requires direct import() support.
const dynamicImportModule = (() => {
    if (process.env.VITEST) {
        return (specifier) => Promise.resolve(`${specifier}`).then(s => __importStar(require(s)));
    }
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    return new Function("specifier", "return import(specifier);");
})();
async function orchestrateIteration(options) {
    return await (0, lock_1.withRunLock)(options.runDir, "runtime:orchestrateIteration", async () => {
        const iterationStartedAt = Date.now();
        const nowFn = resolveNow(options.now);
        const engine = await initializeReplayEngine(options, nowFn, iterationStartedAt);
        const defaultEntrypoint = {
            importPath: engine.metadata.entrypoint?.importPath ?? engine.metadata.processPath,
            exportName: engine.metadata.entrypoint?.exportName,
        };
        const processFn = await loadProcessFunction(options, defaultEntrypoint, options.runDir);
        const inputs = options.inputs ?? engine.inputs;
        let finalStatus = "failed";
        const logger = engine.internalContext.logger ?? options.logger;
        // Compute project root for hook calls (parent of .a5c dir where plugins/ is located)
        // runDir is like: /path/to/project/.a5c/runs/<runId>
        // So we need 3 levels up: runs -> .a5c -> project
        const projectRoot = path_1.default.dirname(path_1.default.dirname(path_1.default.dirname(options.runDir)));
        // Call on-iteration-start hook
        await (0, runtime_1.callRuntimeHook)("on-iteration-start", {
            runId: engine.runId,
            iteration: engine.replayCursor.value,
        }, {
            cwd: projectRoot,
            logger,
        });
        try {
            const output = await (0, processContext_1.withProcessContext)(engine.internalContext, () => processFn(inputs, engine.context, options.context));
            const outputRef = await (0, runFiles_1.writeRunOutput)(options.runDir, output);
            await (0, journal_1.appendEvent)({
                runDir: options.runDir,
                eventType: "RUN_COMPLETED",
                event: {
                    outputRef,
                },
            });
            // Call on-run-complete hook
            await (0, runtime_1.callRuntimeHook)("on-run-complete", {
                runId: engine.runId,
                status: "completed",
                output,
                duration: Date.now() - iterationStartedAt,
            }, {
                cwd: projectRoot,
                logger,
            });
            const result = { status: "completed", output, metadata: createIterationMetadata(engine) };
            finalStatus = result.status;
            return result;
        }
        catch (error) {
            const waiting = asWaitingResult(error);
            if (waiting) {
                finalStatus = waiting.status;
                return {
                    status: "waiting",
                    nextActions: annotateWaitingActions(waiting.nextActions),
                    metadata: createIterationMetadata(engine),
                };
            }
            const failure = (0, errorUtils_1.serializeUnknownError)(error);
            await (0, journal_1.appendEvent)({
                runDir: options.runDir,
                eventType: "RUN_FAILED",
                event: { error: failure },
            });
            // Call on-run-fail hook
            await (0, runtime_1.callRuntimeHook)("on-run-fail", {
                runId: engine.runId,
                status: "failed",
                error: failure.message || "Unknown error",
                duration: Date.now() - iterationStartedAt,
            }, {
                cwd: projectRoot,
                logger,
            });
            const result = {
                status: "failed",
                error: failure,
                metadata: createIterationMetadata(engine),
            };
            finalStatus = result.status;
            return result;
        }
        finally {
            (0, instrumentation_1.emitRuntimeMetric)(logger, "replay.iteration", {
                duration_ms: Date.now() - iterationStartedAt,
                status: finalStatus,
                runId: engine.runId,
                stepCount: engine.replayCursor.value,
            });
            // Call on-iteration-end hook
            await (0, runtime_1.callRuntimeHook)("on-iteration-end", {
                runId: engine.runId,
                iteration: engine.replayCursor.value,
                status: finalStatus,
            }, {
                cwd: projectRoot,
                logger,
            });
        }
    });
}
async function loadProcessFunction(options, defaults, runDir) {
    const importPath = options.process?.importPath ?? defaults.importPath;
    if (!importPath) {
        throw new exceptions_1.RunFailedError("Process import path is missing");
    }
    const exportName = options.process?.exportName ?? defaults.exportName ?? "process";
    const resolvedPath = path_1.default.isAbsolute(importPath) ? importPath : path_1.default.resolve(runDir, importPath);
    const moduleUrl = (0, url_1.pathToFileURL)(resolvedPath).href;
    let mod;
    try {
        mod = await dynamicImportModule(moduleUrl);
    }
    catch (error) {
        throw new exceptions_1.RunFailedError(`Failed to load process module at ${resolvedPath}`, {
            error: (0, errorUtils_1.serializeUnknownError)(error),
        });
    }
    const candidate = (exportName && mod[exportName]) ??
        (!exportName && mod.default) ??
        mod.process ??
        mod.default;
    if (typeof candidate !== "function") {
        throw new exceptions_1.RunFailedError(`Export '${exportName}' was not a function in ${resolvedPath}`);
    }
    return candidate;
}
function asWaitingResult(error) {
    if (error instanceof exceptions_1.ParallelPendingError) {
        return { status: "waiting", nextActions: error.batch.actions };
    }
    if (error instanceof exceptions_1.EffectRequestedError || error instanceof exceptions_1.EffectPendingError) {
        return { status: "waiting", nextActions: [error.action] };
    }
    return null;
}
function resolveNow(now) {
    if (!now)
        return () => new Date();
    if (typeof now === "function") {
        return now;
    }
    const fixed = now;
    return () => fixed;
}
async function initializeReplayEngine(options, nowFn, iterationStartedAt) {
    try {
        return await (0, createReplayEngine_1.createReplayEngine)({ runDir: options.runDir, now: nowFn, logger: options.logger });
    }
    catch (error) {
        (0, instrumentation_1.emitRuntimeMetric)(options.logger, "replay.iteration", {
            duration_ms: Date.now() - iterationStartedAt,
            status: "failed",
            runDir: options.runDir,
            phase: "initialize",
            error: error instanceof Error ? error.message : String(error),
        });
        throw error;
    }
}
function annotateWaitingActions(actions) {
    const pendingCount = actions.length;
    return actions.map((action) => {
        const derivedSleep = deriveSleepHint(action);
        const nextHints = mergeSchedulerHints(action.schedulerHints, {
            pendingCount,
            sleepUntilEpochMs: derivedSleep,
        });
        if (nextHints === action.schedulerHints ||
            (nextHints === undefined && action.schedulerHints === undefined)) {
            return action;
        }
        return {
            ...action,
            schedulerHints: nextHints,
        };
    });
}
function deriveSleepHint(action) {
    if (typeof action.schedulerHints?.sleepUntilEpochMs === "number") {
        return action.schedulerHints.sleepUntilEpochMs;
    }
    const direct = action.taskDef?.sleep?.targetEpochMs;
    if (typeof direct === "number") {
        return direct;
    }
    const metadataTarget = action.taskDef?.metadata?.targetEpochMs;
    return typeof metadataTarget === "number" ? metadataTarget : undefined;
}
function mergeSchedulerHints(base, extra) {
    const merged = { ...(base ?? {}) };
    let changed = false;
    if (extra.pendingCount !== undefined && merged.pendingCount !== extra.pendingCount) {
        merged.pendingCount = extra.pendingCount;
        changed = true;
    }
    if (extra.sleepUntilEpochMs !== undefined &&
        merged.sleepUntilEpochMs !== extra.sleepUntilEpochMs) {
        merged.sleepUntilEpochMs = extra.sleepUntilEpochMs;
        changed = true;
    }
    if (extra.parallelGroupId !== undefined &&
        merged.parallelGroupId !== extra.parallelGroupId) {
        merged.parallelGroupId = extra.parallelGroupId;
        changed = true;
    }
    if (!changed) {
        return base;
    }
    return merged;
}
function createIterationMetadata(engine) {
    return {
        stateVersion: engine.stateCache?.stateVersion,
        pendingEffectsByKind: engine.stateCache?.pendingEffectsByKind,
        journalHead: engine.stateCache?.journalHead ?? null,
        stateRebuilt: Boolean(engine.stateRebuild),
        stateRebuildReason: engine.stateRebuild?.reason ?? null,
    };
}
