"use strict";
/**
 * run:iterate command - Execute one orchestration iteration
 *
 * This command:
 * 1. Calls on-iteration-start hooks to get orchestration decisions
 * 2. Returns effects to stdout as JSON
 * 3. External orchestrator (skill) performs the effects
 * 4. Calls on-iteration-end hooks for finalization
 *
 * The command does NOT loop - it handles exactly one iteration.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.runIterate = runIterate;
const path = __importStar(require("path"));
const runFiles_1 = require("../../storage/runFiles");
const runtime_1 = require("../../runtime/hooks/runtime");
const orchestrateIteration_1 = require("../../runtime/orchestrateIteration");
const completionSecret_1 = require("../completionSecret");
async function runIterate(options) {
    const { runDir, verbose } = options;
    // Read run metadata
    const metadata = await (0, runFiles_1.readRunMetadata)(runDir);
    const runId = metadata.runId;
    // Determine iteration number
    // TODO: Read from state.json or journal
    const iteration = options.iteration ?? 1;
    const projectRoot = path.dirname(path.dirname(path.dirname(runDir)));
    if (verbose) {
        console.error(`[run:iterate] Starting iteration ${iteration} for run ${runId}`);
    }
    // First, advance the runtime one step to request pending effects (if any).
    // This is what creates EFFECT_REQUESTED entries that hooks can observe via task:list.
    const iterationResult = await (0, orchestrateIteration_1.orchestrateIteration)({ runDir });
    if (iterationResult.status === "completed") {
        const completionSecret = (0, completionSecret_1.resolveCompletionSecret)(metadata);
        await (0, runtime_1.callRuntimeHook)("on-iteration-end", {
            runId,
            iteration,
            action: "none",
            status: "completed",
            reason: "completed",
            timestamp: new Date().toISOString(),
        }, { cwd: projectRoot, logger: verbose ? ((msg) => console.error(msg)) : undefined });
        return {
            iteration,
            status: "completed",
            action: "none",
            reason: "completed",
            completionSecret,
            metadata: { runId, processId: metadata.processId, hookStatus: "executed" },
        };
    }
    if (iterationResult.status === "failed") {
        await (0, runtime_1.callRuntimeHook)("on-iteration-end", {
            runId,
            iteration,
            action: "none",
            status: "failed",
            reason: "failed",
            timestamp: new Date().toISOString(),
        }, { cwd: projectRoot, logger: verbose ? ((msg) => console.error(msg)) : undefined });
        return {
            iteration,
            status: "failed",
            action: "none",
            reason: "failed",
            metadata: { runId, processId: metadata.processId, hookStatus: "executed" },
        };
    }
    // === Call on-iteration-start hook ===
    // Hook may execute/post effects that were requested by orchestrateIteration().
    const iterationStartPayload = {
        runId,
        iteration,
        status: iterationResult.status,
        pending: iterationResult.status === "waiting" ? iterationResult.nextActions : [],
        timestamp: new Date().toISOString(),
    };
    const hookResult = await (0, runtime_1.callRuntimeHook)("on-iteration-start", iterationStartPayload, {
        cwd: projectRoot,
        logger: verbose ? ((msg) => console.error(msg)) : undefined,
    });
    // Parse hook output
    const hookDecision = parseHookDecision(hookResult.output);
    const action = hookDecision.action ?? "none";
    const reason = hookDecision.reason ?? "unknown";
    const count = hookDecision.count;
    const until = hookDecision.until;
    if (verbose) {
        console.error(`[run:iterate] Hook action: ${action}, reason: ${reason}${count ? `, count: ${count}` : ""}`);
    }
    // Determine result status based on hook action
    let status;
    if (action === "executed-tasks") {
        status = "executed";
    }
    else if (action === "waiting") {
        status = "waiting";
    }
    else if (iterationResult.status === "waiting") {
        // If the hook didn't execute anything, surface runtime waiting details.
        status = "waiting";
    }
    else {
        status = "none";
    }
    // === Call on-iteration-end hook ===
    const iterationEndPayload = {
        runId,
        iteration,
        action,
        status,
        reason,
        count,
        timestamp: new Date().toISOString(),
    };
    await (0, runtime_1.callRuntimeHook)("on-iteration-end", iterationEndPayload, {
        cwd: projectRoot,
        logger: verbose ? ((msg) => console.error(msg)) : undefined,
    });
    // Return result
    const result = {
        iteration,
        status,
        action,
        reason,
        count,
        until,
        nextActions: iterationResult.status === "waiting" ? iterationResult.nextActions : undefined,
        metadata: {
            runId,
            processId: metadata.processId,
            hookStatus: hookResult.executedHooks?.length > 0 ? "executed" : "none",
        },
    };
    return result;
}
function parseHookDecision(output) {
    const record = parseMaybeJsonRecord(output);
    if (!record)
        return {};
    const action = typeof record.action === "string" ? record.action : undefined;
    const reason = typeof record.reason === "string" ? record.reason : undefined;
    const status = typeof record.status === "string" ? record.status : undefined;
    const count = typeof record.count === "number" ? record.count : undefined;
    const until = typeof record.until === "number" ? record.until : undefined;
    return { action, reason, status, count, until };
}
function parseMaybeJsonRecord(output) {
    if (!output)
        return undefined;
    if (typeof output === "object" && !Array.isArray(output)) {
        return output;
    }
    if (typeof output !== "string")
        return undefined;
    try {
        const parsed = JSON.parse(output);
        return parsed && typeof parsed === "object" && !Array.isArray(parsed) ? parsed : undefined;
    }
    catch {
        return undefined;
    }
}
