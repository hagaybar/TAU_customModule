"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runToCompletionWithFakeRunner = runToCompletionWithFakeRunner;
const orchestrateIteration_1 = require("../runtime/orchestrateIteration");
const commitEffectResult_1 = require("../runtime/commitEffectResult");
const DEFAULT_MAX_ITERATIONS = 100;
async function runToCompletionWithFakeRunner(options) {
    const { runDir, resolve, logger, onIteration } = options;
    const maxIterations = options.maxIterations ?? DEFAULT_MAX_ITERATIONS;
    if (maxIterations <= 0 || !Number.isFinite(maxIterations)) {
        throw new Error("maxIterations must be a positive finite number");
    }
    const cleanupProviders = applyDeterministicProviders(options.clock, options.ulids);
    const executed = [];
    const executionLog = [];
    let iterations = 0;
    try {
        while (iterations < maxIterations) {
            iterations += 1;
            const clockHandle = options.clock;
            const deterministicNow = clockHandle ? () => clockHandle.now() : undefined;
            const iteration = await (0, orchestrateIteration_1.orchestrateIteration)({
                runDir,
                logger,
                now: resolveNowOption(options.now ?? deterministicNow),
            });
            await onIteration?.(iteration);
            const iterationLog = {
                iteration: iterations,
                status: iteration.status,
                metadata: iteration.metadata ?? null,
                pending: iteration.status === "waiting" ? iteration.nextActions.map(snapshotAction) : [],
                executed: [],
            };
            if (iteration.status === "completed") {
                executionLog.push(iterationLog);
                return {
                    status: "completed",
                    output: iteration.output,
                    metadata: iteration.metadata ?? null,
                    executed,
                    iterations,
                    executionLog,
                };
            }
            if (iteration.status === "failed") {
                executionLog.push(iterationLog);
                return {
                    status: "failed",
                    error: iteration.error,
                    metadata: iteration.metadata ?? null,
                    executed,
                    iterations,
                    executionLog,
                };
            }
            if (iteration.status !== "waiting") {
                executionLog.push(iterationLog);
                throw new Error("Unexpected iteration status");
            }
            const pendingActions = iteration.nextActions;
            const executedThisIteration = [];
            let handled = false;
            for (const action of pendingActions) {
                const resolution = await resolve(action);
                if (!resolution) {
                    continue;
                }
                handled = true;
                await (0, commitEffectResult_1.commitEffectResult)({
                    runDir,
                    effectId: action.effectId,
                    invocationKey: action.invocationKey,
                    result: toCommitResult(resolution),
                });
                const entry = { action, resolution };
                executedThisIteration.push(entry);
                executed.push(entry);
            }
            iterationLog.executed = executedThisIteration.map(({ action }) => snapshotAction(action));
            executionLog.push(iterationLog);
            if (!handled) {
                return {
                    status: "waiting",
                    pending: pendingActions,
                    metadata: iteration.metadata ?? null,
                    executed,
                    iterations,
                    executionLog,
                };
            }
        }
        throw new Error(`runToCompletionWithFakeRunner exceeded maxIterations=${maxIterations}`);
    }
    finally {
        cleanupProviders();
    }
}
function toCommitResult(resolution) {
    const base = {
        stdout: resolution.stdout,
        stderr: resolution.stderr,
        startedAt: resolution.startedAt,
        finishedAt: resolution.finishedAt,
        metadata: resolution.metadata,
    };
    if (resolution.status === "ok") {
        return {
            status: "ok",
            value: resolution.value,
            ...base,
        };
    }
    if (resolution.error === undefined) {
        throw new Error("FakeActionResolution.status='error' requires an error payload");
    }
    return {
        status: "error",
        error: resolution.error,
        ...base,
    };
}
function snapshotAction(action) {
    return {
        effectId: action.effectId,
        invocationKey: action.invocationKey,
        taskId: action.taskId,
        stepId: action.stepId,
        kind: action.kind,
        schedulerHints: action.schedulerHints,
    };
}
function resolveNowOption(now) {
    if (!now)
        return () => new Date();
    if (typeof now === "function") {
        return now;
    }
    const fixed = now;
    return () => fixed;
}
function applyDeterministicProviders(clock, ulids) {
    const restoreFns = [];
    if (clock) {
        restoreFns.push(clock.apply());
    }
    if (ulids) {
        restoreFns.push(ulids.apply());
    }
    return () => {
        while (restoreFns.length > 0) {
            const restore = restoreFns.pop();
            try {
                restore?.();
            }
            catch {
                // ignore cleanup errors
            }
        }
    };
}
