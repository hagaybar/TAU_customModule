"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeTaskDefinition = writeTaskDefinition;
exports.readTaskDefinition = readTaskDefinition;
exports.readTaskResult = readTaskResult;
exports.writeTaskResult = writeTaskResult;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const paths_1 = require("./paths");
const atomic_1 = require("./atomic");
function resolveTaskPath(runDir, effectId, relative) {
    return path_1.default.join((0, paths_1.getTasksDir)(runDir), effectId, relative);
}
async function writeTaskDefinition(runDir, effectId, taskDef) {
    const taskDir = path_1.default.join((0, paths_1.getTasksDir)(runDir), effectId);
    await fs_1.promises.mkdir(taskDir, { recursive: true });
    const taskPath = path_1.default.join(taskDir, "task.json");
    await (0, atomic_1.writeFileAtomic)(taskPath, JSON.stringify(taskDef, null, 2) + "\n");
    return path_1.default.relative(runDir, taskPath).replace(/\\/g, "/");
}
async function readTaskDefinition(runDir, effectId) {
    const taskPath = resolveTaskPath(runDir, effectId, "task.json");
    try {
        const raw = await fs_1.promises.readFile(taskPath, "utf8");
        return JSON.parse(raw);
    }
    catch (error) {
        const err = error;
        if (err.code === "ENOENT") {
            return undefined;
        }
        throw error;
    }
}
async function readTaskResult(runDir, effectId, resultRef) {
    const resolvedPath = resultRef
        ? path_1.default.isAbsolute(resultRef)
            ? resultRef
            : path_1.default.join(runDir, resultRef)
        : resolveTaskPath(runDir, effectId, "result.json");
    try {
        const raw = await fs_1.promises.readFile(resolvedPath, "utf8");
        return JSON.parse(raw);
    }
    catch (error) {
        const err = error;
        if (err.code === "ENOENT") {
            return undefined;
        }
        throw error;
    }
}
async function writeTaskResult(options) {
    const taskDir = path_1.default.join((0, paths_1.getTasksDir)(options.runDir), options.effectId);
    await fs_1.promises.mkdir(taskDir, { recursive: true });
    const resultPath = path_1.default.join(taskDir, "result.json");
    const relativeResultPath = path_1.default.relative(options.runDir, resultPath).replace(/\\/g, "/");
    const stdoutRef = await writeTextIfProvided(options.runDir, options.effectId, "stdout.log", options.stdout);
    const stderrRef = await writeTextIfProvided(options.runDir, options.effectId, "stderr.log", options.stderr);
    if (stdoutRef && !options.result.stdoutRef) {
        options.result.stdoutRef = stdoutRef;
    }
    if (stderrRef && !options.result.stderrRef) {
        options.result.stderrRef = stderrRef;
    }
    await (0, atomic_1.writeFileAtomic)(resultPath, JSON.stringify(options.result, null, 2) + "\n");
    return {
        resultRef: relativeResultPath,
        stdoutRef,
        stderrRef,
    };
}
async function writeTextIfProvided(runDir, effectId, filename, contents) {
    if (typeof contents !== "string")
        return undefined;
    const filePath = resolveTaskPath(runDir, effectId, filename);
    await (0, atomic_1.writeFileAtomic)(filePath, contents);
    return path_1.default.relative(runDir, filePath).replace(/\\/g, "/");
}
