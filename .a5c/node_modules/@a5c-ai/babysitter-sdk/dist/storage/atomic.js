"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFileAtomic = writeFileAtomic;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const RETRYABLE_ERRORS = new Set(["EBUSY", "ETXTBSY", "EPERM", "EACCES"]);
async function fsyncPath(targetPath) {
    const handle = await fs_1.promises.open(targetPath, "r");
    try {
        await handle.sync();
    }
    finally {
        await handle.close();
    }
}
async function writeFileAtomic(targetPath, data, retries = 3) {
    await fs_1.promises.mkdir(path_1.default.dirname(targetPath), { recursive: true });
    const tempPath = `${targetPath}.tmp-${process.pid}-${Date.now()}`;
    const handle = await fs_1.promises.open(tempPath, "w");
    try {
        if (typeof data === "string") {
            await handle.writeFile(data, "utf8");
        }
        else {
            await handle.writeFile(data);
        }
        await handle.sync();
    }
    finally {
        await handle.close();
    }
    for (let attempt = 0; attempt <= retries; attempt++) {
        try {
            await fs_1.promises.rename(tempPath, targetPath);
            await fsyncPath(path_1.default.dirname(targetPath));
            return;
        }
        catch (error) {
            const err = error;
            if (err.code === "ENOENT") {
                await fs_1.promises.writeFile(targetPath, data);
                return;
            }
            if (attempt === retries || !err.code || !RETRYABLE_ERRORS.has(err.code)) {
                await fs_1.promises.rm(tempPath, { force: true });
                throw err;
            }
            await new Promise((resolve) => setTimeout(resolve, (attempt + 1) * 25));
        }
    }
}
