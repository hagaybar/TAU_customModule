"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDiskUsage = getDiskUsage;
exports.findOrphanedBlobs = findOrphanedBlobs;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const paths_1 = require("./paths");
async function dirSize(dir) {
    try {
        const entries = await fs_1.promises.readdir(dir, { withFileTypes: true });
        let total = 0;
        for (const entry of entries) {
            const full = path_1.default.join(dir, entry.name);
            if (entry.isDirectory()) {
                total += await dirSize(full);
            }
            else if (entry.isFile()) {
                const stat = await fs_1.promises.stat(full);
                total += stat.size;
            }
        }
        return total;
    }
    catch (err) {
        const error = err;
        if (error.code === "ENOENT")
            return 0;
        throw error;
    }
}
async function getDiskUsage(runsRoot, runId) {
    const runDir = (0, paths_1.getRunDir)(runsRoot, runId);
    const [journal, tasks, blobs, state] = await Promise.all([
        dirSize((0, paths_1.getJournalDir)(runDir)),
        dirSize((0, paths_1.getTasksDir)(runDir)),
        dirSize((0, paths_1.getBlobsDir)(runDir)),
        dirSize((0, paths_1.getStateDir)(runDir)),
    ]);
    const total = journal + tasks + blobs + state;
    return { totalBytes: total, journalBytes: journal, tasksBytes: tasks, blobsBytes: blobs, stateBytes: state };
}
async function findOrphanedBlobs(runsRoot, runId) {
    const runDir = (0, paths_1.getRunDir)(runsRoot, runId);
    const blobsDir = (0, paths_1.getBlobsDir)(runDir);
    const referenced = new Set();
    const tasksDir = (0, paths_1.getTasksDir)(runDir);
    try {
        const effects = await fs_1.promises.readdir(tasksDir, { withFileTypes: true });
        for (const effectEntry of effects) {
            if (!effectEntry.isDirectory())
                continue;
            const artifactsPath = path_1.default.join(tasksDir, effectEntry.name, "artifacts.json");
            try {
                const data = await fs_1.promises.readFile(artifactsPath, "utf8");
                const artifacts = JSON.parse(data);
                for (const artifact of artifacts) {
                    if (artifact.storedAt.startsWith("blobs/")) {
                        referenced.add(path_1.default.basename(artifact.storedAt));
                    }
                }
            }
            catch (err) {
                const error = err;
                if (error.code !== "ENOENT")
                    throw err;
            }
        }
    }
    catch (err) {
        const error = err;
        if (error.code !== "ENOENT")
            throw err;
    }
    const orphaned = [];
    try {
        const blobs = await fs_1.promises.readdir(blobsDir, { withFileTypes: true });
        for (const blob of blobs) {
            if (!blob.isFile())
                continue;
            if (!referenced.has(blob.name)) {
                const full = path_1.default.join(blobsDir, blob.name);
                const stat = await fs_1.promises.stat(full);
                orphaned.push({ hash: blob.name, bytes: stat.size, path: `blobs/${blob.name}` });
            }
        }
    }
    catch (err) {
        const error = err;
        if (error.code !== "ENOENT")
            throw err;
    }
    return orphaned;
}
