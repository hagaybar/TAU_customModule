"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.acquireRunLock = acquireRunLock;
exports.releaseRunLock = releaseRunLock;
exports.readRunLock = readRunLock;
exports.withRunLock = withRunLock;
const fs_1 = require("fs");
const paths_1 = require("./paths");
const clock_1 = require("./clock");
async function acquireRunLock(runDir, owner) {
    const lockPath = (0, paths_1.getLockPath)(runDir);
    const lockInfo = { pid: process.pid, owner, acquiredAt: (0, clock_1.getClockIsoString)() };
    try {
        await fs_1.promises.writeFile(lockPath, JSON.stringify(lockInfo, null, 2) + "\n", { flag: "wx" });
        return lockInfo;
    }
    catch (error) {
        const err = error;
        if (err.code === "EEXIST") {
            const existing = JSON.parse(await fs_1.promises.readFile(lockPath, "utf8"));
            throw new Error(`run.lock already held by pid ${existing.pid} (${existing.owner})`);
        }
        throw err;
    }
}
async function releaseRunLock(runDir) {
    const lockPath = (0, paths_1.getLockPath)(runDir);
    await fs_1.promises.rm(lockPath, { force: true });
}
async function readRunLock(runDir) {
    const lockPath = (0, paths_1.getLockPath)(runDir);
    try {
        const data = await fs_1.promises.readFile(lockPath, "utf8");
        return JSON.parse(data);
    }
    catch (error) {
        const err = error;
        if (err.code === "ENOENT")
            return null;
        throw err;
    }
}
function isLockHeldError(error) {
    if (!(error instanceof Error))
        return false;
    return error.message.startsWith("run.lock already held");
}
async function sleep(ms) {
    await new Promise((resolve) => setTimeout(resolve, ms));
}
async function withRunLock(runDir, owner, fn, options = {}) {
    const retries = typeof options.retries === "number" ? Math.max(0, Math.floor(options.retries)) : 40;
    const delayMs = typeof options.delayMs === "number" ? Math.max(0, Math.floor(options.delayMs)) : 250;
    let acquired = false;
    for (let attempt = 0; attempt <= retries; attempt += 1) {
        try {
            await acquireRunLock(runDir, owner);
            acquired = true;
            break;
        }
        catch (error) {
            if (!isLockHeldError(error) || attempt === retries) {
                throw error;
            }
            await sleep(delayMs);
        }
    }
    try {
        return await fn();
    }
    finally {
        if (acquired) {
            await releaseRunLock(runDir);
        }
    }
}
